<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>TAKE A TRIP! Glitch Art & Datamosh in Real-time</title>
    <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
    <style>
        @keyframes rainbowText {
            0% { color: #ff00ff; text-shadow: 0 0 7px #ff00ff; } 16% { color: #007bff; text-shadow: 0 0 7px #007bff; } 33% { color: #00ff00; text-shadow: 0 0 7px #00ff00; } 50% { color: #ffff00; text-shadow: 0 0 7px #ffff00; } 66% { color: #ff7f00; text-shadow: 0 0 7px #ff7f00; } 83% { color: #ff0000; text-shadow: 0 0 7px #ff0000; } 100% { color: #ff00ff; text-shadow: 0 0 7px #ff00ff; }
        }
        @keyframes rainbowBackground {
            0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; }
        }
        @keyframes blink {
            0%, 100% { opacity: 1; } 50% { opacity: 0.4; }
        }
        html, body { margin: 0; padding: 0; overflow: hidden; width: 100%; height: 100%; background-color: #0a0a0f; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; color: #e8e8e8; }
        canvas { display: block; width: 100%; height: 100%; object-fit: contain; }
        #errorMessage { position: absolute; top: 10px; left: 10px; background-color: rgba(255, 0, 100, 0.9); padding: 12px; border-radius: 6px; display: none; z-index: 1001; color: white; font-size: 14px; box-shadow: 0 0 20px rgba(255,0,100,0.7); }
        #webcamVideo { position: absolute; top: -9999px; left: -9999px; }
        #controls { position: absolute; bottom: 10px; left: 10px; background-color: rgba(15, 18, 28, 0.65); padding: 12px; border-radius: 12px; font-size: 12px; display: flex; flex-direction: column; width: 290px; max-width: 90vw; max-height: 88vh; z-index: 1000; overflow: hidden; min-width: 240px; border: 1px solid rgba(70, 80, 110, 0.8); box-shadow: 0 8px 35px rgba(0,0,0,0.6), 0 0 50px rgba(100, 150, 255, 0.1); transition: height 0.3s cubic-bezier(0.25, 0.1, 0.25, 1), min-height 0.3s cubic-bezier(0.25, 0.1, 0.25, 1), opacity 0.3s ease-out; }
        #controlsHeader { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; padding-bottom: 8px; border-bottom: 1px solid rgba(60, 70, 95, 0.8); position: relative; }
        #headerButtons { display: flex; align-items: center; gap: 8px; }
        #controlsTitle { font-weight: 700; font-size: 18px; animation: rainbowText 10s linear infinite; margin-right: auto; }
        #minimizeButton { background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(120, 150, 200, 0.5); color: #aaa; cursor: pointer; padding: 0; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; transition: background-color 0.2s, transform 0.2s, color 0.2s, box-shadow 0.2s; flex-shrink: 0; }
        #minimizeButton:hover { background: rgba(255, 255, 255, 0.15); color: #fff; transform: scale(1.15); box-shadow: 0 0 10px rgba(150, 180, 255, 0.5); }
        #minimizeButton svg { width: 12px; height: 12px; fill: currentColor; }
        #controlsContent { overflow-y: auto; overflow-x: hidden; padding-right: 3px; display: flex; flex-direction: column; gap: 10px; transition: opacity 0.2s 0.1s ease-out; }
        #controls.minimized { height: 52px !important; min-height: 52px !important; background-color: rgba(15, 18, 28, 0.55); }
        #controls.minimized #controlsContent, #controls.minimized #resizeHandle { opacity: 0; pointer-events: none; }
        #controls .main-action-button { width: 100%; box-sizing: border-box; margin-top: 6px; padding: 7px 10px; background: linear-gradient(120deg, red, orange, yellow, green, blue, indigo, violet, red); background-size: 300% 300%; animation: rainbowBackground 8s linear infinite; border: none; color: white; cursor: pointer; border-radius: 6px; font-size: 12px; font-weight: 600; transition: transform 0.15s ease, box-shadow 0.15s ease; text-shadow: 0 1px 3px rgba(0,0,0,0.3); }
        #controls .main-action-button:hover { transform: translateY(-2px) scale(1.02); box-shadow: 0 6px 15px rgba(0,0,0,0.2); }
        #controls .main-action-button:active { transform: translateY(0px) scale(1); animation-duration: 4s; }
        #controls .main-action-button:disabled { background-image: none; background-color: #3a3a45; color: #777; cursor: default; transform: none; box-shadow: none; animation: none; }
        .control-group { display: flex; flex-wrap: nowrap; align-items: center; gap: 8px; }
        .control-group label { flex-basis: 75px; flex-shrink: 0; font-size: 12.5px; font-weight: 500; color: #77ccff; text-shadow: 0 0 5px rgba(100, 200, 255, 0.5); }
        .control-group input[type="range"] { flex-grow: 1; min-width: 80px; height: 20px; margin: 0; -webkit-appearance: none; appearance: none; background: transparent; cursor: pointer; }
        .control-group input[type="range"]::-webkit-slider-runnable-track { height: 10px; background: linear-gradient(90deg, #ff00ff, #00ffff, #ffff00, #ff00ff, #00ffff, #ffff00); background-size: 400% 100%; animation: rainbowBackground 12s linear infinite; border-radius: 5px; box-shadow: inset 0 1px 3px rgba(0,0,0,0.4); }
        .control-group input[type="range"]::-moz-range-track { height: 10px; background: linear-gradient(90deg, #ff00ff, #00ffff, #ffff00, #ff00ff, #00ffff, #ffff00); background-size: 400% 100%; animation: rainbowBackground 12s linear infinite; border-radius: 5px; border: none; }
        .control-group input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; height: 18px; width: 18px; background-color: #ffffff; border-radius: 50%; border: 2px solid #10121a; box-shadow: 0 0 6px #fff, 0 0 12px #fff, 0 0 18px rgba(200,220,255,0.8); margin-top: -4px; }
        .control-group input[type="range"]::-moz-range-thumb { height: 16px; width: 16px; background-color: #ffffff; border-radius: 50%; border: 2px solid #10121a; box-shadow: 0 0 6px #fff, 0 0 12px #fff, 0 0 18px rgba(200,220,255,0.8); }
        .control-group input[type="number"] { width: 55px; flex-shrink: 0; text-align: right; padding: 5px 6px; background-color: rgba(20, 22, 30, 0.8); color: #66ffee; border: 1px solid rgba(80, 90, 120, 0.9); border-radius: 4px; -moz-appearance: textfield; appearance: textfield; font-size: 12px; font-weight: 500; box-shadow: inset 0 1px 3px rgba(0,0,0,0.3); }
        .control-group input[type="number"]::-webkit-outer-spin-button, .control-group input[type="number"]::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
        .button-group { display: flex; gap: 10px; margin-top: 8px; }
        .button-group button { flex-grow: 1; }
        #resizeHandle { position: absolute; bottom: 0; right: 0; width: 16px; height: 16px; cursor: nwse-resize; z-index: 1000; display: flex; align-items: flex-end; justify-content: flex-end; opacity: 0.4; }
        #resizeHandle::before { content: ""; display: block; width: 8px; height: 8px; border-right: 2.5px solid #66ffee; border-bottom: 2.5px solid #66ffee; margin: 0 2px 2px 0; opacity: 0.6; }
        #resizeHandle:hover { opacity: 0.8; }
        .record-button { padding: 0; background-color: #282c34; border: 1px solid #4f5661; cursor: pointer; border-radius: 50%; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; transition: background-color 0.2s, transform 0.15s ease, box-shadow 0.15s ease; box-shadow: 0 2px 5px rgba(0,0,0,0.3); flex-shrink: 0; color: #e8e8e8; }
        .record-button:hover { background-color: #3a3f47; transform: scale(1.05); box-shadow: 0 4px 10px rgba(0,0,0,0.4); }
        .record-button:active { background-color: #1c1e22; transform: scale(1); }
        .record-button.is-recording { animation: blink 1.5s linear infinite; }
        .record-button svg { display: block; margin: auto; }
        #fileUploadInput { background-color: rgba(20, 22, 30, 0.8); color: #e8e8e8; border: 1px solid rgba(80, 90, 120, 0.9); border-radius: 4px; padding: 4px; font-size: 11px; flex-grow: 1; }
        #fileUploadInput::file-selector-button { background-color: #3a3f47; color: #e8e8e8; border: none; padding: 3px 6px; border-radius: 3px; cursor: pointer; margin-right: 8px; }
        #donateButton { background-color: rgba(255, 105, 180, 0.15); border: 1px solid rgba(255, 105, 180, 0.6); color: #ffadc9; }
        #donateButton:hover { background-color: rgba(255, 105, 180, 0.3); box-shadow: 0 0 10px rgba(255, 105, 180, 0.5); color: #ffe0f0; }
        #donateButton svg { width: 16px; height: 16px; fill: currentColor; }
        #donateModal { display: none; position: fixed; z-index: 2000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(10, 10, 15, 0.85); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); }
        .donate-modal-content { background-color: #181b26; margin: 8vh auto; padding: 25px; border: 1px solid rgba(100, 120, 180, 0.7); border-radius: 15px; width: 90%; max-width: 500px; box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7), 0 0 60px rgba(120, 150, 255, 0.15); position: relative; color: #ccc; }
        .donate-close-button { color: #aaa; position: absolute; top: 10px; right: 15px; font-size: 28px; font-weight: bold; line-height: 1; transition: color 0.2s ease, transform 0.2s ease; }
        .donate-close-button:hover, .donate-close-button:focus { color: #ff6b6b; text-decoration: none; cursor: pointer; transform: scale(1.1); }
        .donate-modal-content h2 { margin-top: 0; margin-bottom: 20px; color: #ffb6c1; text-align: center; font-weight: 600; text-shadow: 0 0 8px rgba(255, 192, 203, 0.6); }
        .donation-list { list-style: none; padding: 0; margin: 0; display: flex; flex-direction: column; gap: 15px; }
        .donation-option { background-color: rgba(30, 35, 50, 0.5); padding: 12px 15px; border-radius: 8px; border: 1px solid rgba(60, 70, 100, 0.6); }
        .donation-label { font-weight: 600; font-size: 13px; color: #66ffee; margin-bottom: 8px; display: block; }
        .donation-label span { font-weight: 400; font-size: 11px; color: #c8c8c8; margin-left: 5px; }
        .donation-address-container { display: flex; align-items: center; gap: 8px; background-color: rgba(10, 12, 18, 0.6); padding: 8px 10px; border-radius: 5px; border: 1px solid rgba(80, 90, 120, 0.7); margin-bottom: 8px; }
        .donation-address { flex-grow: 1; font-family: 'Courier New', Courier, monospace; font-size: 13px; color: #fff; word-break: break-all; background: none; border: none; padding: 0; margin: 0; outline: none; line-height: 1.4; }
        .donation-actions button { background: rgba(255, 255, 255, 0.08); border: 1px solid rgba(120, 150, 200, 0.5); color: #aaa; cursor: pointer; padding: 5px 8px; border-radius: 4px; font-size: 11px; transition: background-color 0.2s, color 0.2s, transform 0.1s; flex-shrink: 0; }
        .donation-actions button:hover { background: rgba(255, 255, 255, 0.18); color: #fff; transform: translateY(-1px); }
        .donation-actions button:active { transform: translateY(0px); }
        .donation-actions button.copied { background-color: #28a745; color: white; border-color: #28a745; }
        .qr-code-area { display: flex; justify-content: center; align-items: center; padding: 5px 0; }
        .qr-code-container { background-color: white; padding: 10px; border-radius: 6px; display: inline-block; line-height: 0; border: 1px solid #ddd; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        .qr-code-container canvas { width: 128px !important; height: 128px !important; }
        .donation-disclaimer { font-size: 15px; color: #ffb6c1; text-align: center; margin-top: 20px; opacity: 0.8; }
    </style>
</head>
<body>
    <canvas id="outputCanvas"></canvas>
    <video id="webcamVideo" playsinline autoplay muted></video>
    <div id="errorMessage"></div>
    <div id="controls">
        <div id="controlsHeader">
            <span id="controlsTitle">TAKE A TRIP!</span>
            <div id="headerButtons">
                <button id="recordButton" class="record-button" title="Start Recording"></button>
                <button id="switchCameraButton" class="record-button" title="Switch Camera" style="display: none;"></button>
                <button id="donateButton" class="record-button" title="Show Some Love ❤️">
                    <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>
                </button>
                <button id="minimizeButton" title="Minimize Controls">
                    <svg viewBox="0 0 24 24"><path d="M19 13H5v-2h14v2z"/></svg>
                </button>
            </div>
        </div>
        <div id="controlsContent">
            <div class="control-group"> <label for="trailRange">Trailing:</label> <input type="range" id="trailRange" min="0.0" max="1.5" step="0.005" value="0.9"> <input type="number" id="trailNumber" step="0.005" value="0.9"> </div>
            <div class="control-group"> <label for="motionRange">Motion:</label> <input type="range" id="motionRange" min="0.0" max="1.0" step="0.01" value="0.12"> <input type="number" id="motionNumber" step="0.01" value="0.12"> </div>
            <div class="control-group"> <label for="hueRange">Hue:</label> <input type="range" id="hueRange" min="-0.2" max="0.2" step="0.001" value="0.0"> <input type="number" id="hueNumber" step="0.001" value="0.0"> </div>
            <div class="control-group"> <label for="historyRange">Buffer:</label> <input type="range" id="historyRange" min="1" max="16" step="1" value="6"> <input type="number" id="historyNumber" min="1" max="16" step="1" value="6"> </div>
            <div class="control-group"> <label for="extrapRange">Extrapolate:</label> <input type="range" id="extrapRange" min="0.0" max="2.0" step="0.01" value="0.0"> <input type="number" id="extrapNumber" step="0.01" value="0.0"> </div>
            <div class="button-group"> <button id="freezeButton" class="main-action-button">Freeze Frame (0)</button> <button id="clearFreezeButton" class="main-action-button" disabled>Clear Frozen</button> </div>
            <button id="randomizeButton" class="main-action-button">Randomize Sliders</button>
            <div class="control-group" style="margin-top: 10px;"> <label for="fileUploadInput" style="flex-basis: auto; margin-right: 5px; white-space: nowrap;">Upload:</label> <input type="file" id="fileUploadInput" accept="image/*,video/*"> </div>
            <button id="useWebcamButton" class="main-action-button" style="display: none; margin-top: 5px;">Use Webcam</button>
        </div>
        <div id="resizeHandle"></div>
    </div>
    <div id="donateModal">
        <div class="donate-modal-content">
            <span class="donate-close-button">&times;</span>
            <h2>All Donations Are Highly Appreciated! ❤️</h2>
            <ul class="donation-list">
                <li class="donation-option">
                    <label class="donation-label">Bitcoin <span>(BTC)</span></label>
                    <div class="donation-address-container">
                        <code class="donation-address">bc1qecdj56jhq6z38aatu8emyeg5shhm239cs8q7mt</code>
                        <div class="donation-actions">
                            <button class="copy-button" data-address="bc1qecdj56jhq6z38aatu8emyeg5shhm239cs8q7mt">Copy</button>
                            <button class="qr-button" data-address="bc1qecdj56jhq6z38aatu8emyeg5shhm239cs8q7mt">QR</button>
                        </div>
                    </div>
                    <div class="qr-code-area" style="display: none;"><div class="qr-code-container"></div></div>
                </li>
                <li class="donation-option">
                    <label class="donation-label">EVM: ERC-20 / Polygon / BSC <span>(ETH, BNB, MATIC, USDC, etc.)</span></label>
                    <div class="donation-address-container">
                        <code class="donation-address">0xfB82fEDf673E7b98e99a54ed6F926168B634e34A</code>
                        <div class="donation-actions">
                            <button class="copy-button" data-address="0xfB82fEDf673E7b98e99a54ed6F926168B634e34A">Copy</button>
                            <button class="qr-button" data-address="0xfB82fEDf673E7b98e99a54ed6F926168B634e34A">QR</button>
                        </div>
                    </div>
                     <div class="qr-code-area" style="display: none;"><div class="qr-code-container"></div></div>
                </li>
                 <li class="donation-option">
                    <label class="donation-label">TRC-20 <span>(USDT, TRX)</span></label>
                    <div class="donation-address-container">
                        <code class="donation-address">TMfkayH5QnzkbX2sooyfdyPn9JgoL2b6Ln</code>
                        <div class="donation-actions">
                            <button class="copy-button" data-address="TMfkayH5QnzkbX2sooyfdyPn9JgoL2b6Ln">Copy</button>
                            <button class="qr-button" data-address="TMfkayH5QnzkbX2sooyfdyPn9JgoL2b6Ln">QR</button>
                        </div>
                    </div>
                     <div class="qr-code-area" style="display: none;"><div class="qr-code-container"></div></div>
                </li>
                 <li class="donation-option">
                    <label class="donation-label">Solana <span>(SOL, USDC)</span></label>
                    <div class="donation-address-container">
                        <code class="donation-address">9W2MVbsmvNboSPWM5fxFG1TmKi2VrXWeFdd21eKxCaE5</code>
                        <div class="donation-actions">
                            <button class="copy-button" data-address="9W2MVbsmvNboSPWM5fxFG1TmKi2VrXWeFdd21eKxCaE5">Copy</button>
                            <button class="qr-button" data-address="9W2MVbsmvNboSPWM5fxFG1TmKi2VrXWeFdd21eKxCaE5">QR</button>
                        </div>
                    </div>
                    <div class="qr-code-area" style="display: none;"><div class="qr-code-container"></div></div>
                </li>
                 <li class="donation-option">
                    <label class="donation-label">Litecoin <span>(LTC)</span></label>
                    <div class="donation-address-container">
                        <code class="donation-address">ltc1qqys93yv639v22nvj7pt9un0hdye3yhysrk02ud</code>
                        <div class="donation-actions">
                            <button class="copy-button" data-address="ltc1qqys93yv639v22nvj7pt9un0hdye3yhysrk02ud">Copy</button>
                            <button class="qr-button" data-address="ltc1qqys93yv639v22nvj7pt9un0hdye3yhysrk02ud">QR</button>
                        </div>
                    </div>
                     <div class="qr-code-area" style="display: none;"><div class="qr-code-container"></div></div>
                </li>
                 <li class="donation-option">
                    <label class="donation-label">Dogecoin <span>(DOGE)</span></label>
                    <div class="donation-address-container">
                        <code class="donation-address">D8TCYTMJCSXTQ2Kh98qefwoQntJNkPU1A9</code>
                        <div class="donation-actions">
                            <button class="copy-button" data-address="D8TCYTMJCSXTQ2Kh98qefwoQntJNkPU1A9">Copy</button>
                            <button class="qr-button" data-address="D8TCYTMJCSXTQ2Kh98qefwoQntJNkPU1A9">QR</button>
                        </div>
                    </div>
                     <div class="qr-code-area" style="display: none;"><div class="qr-code-container"></div></div>
                </li>
            </ul>
            <p class="donation-disclaimer">
                Thank you for chipping in! Every bit helps me dedicate more time to creating new exciting projects. I've got some cool ideas on the way!
            </p>
        </div>
    </div>
    <script>
        const vsSource = ` attribute vec4 a_position; attribute vec2 a_texCoord; varying vec2 v_texCoord; void main() { gl_Position = a_position; v_texCoord = a_texCoord; } `;
        const fsSource = `
            precision highp float; varying vec2 v_texCoord;
            uniform sampler2D u_webcamTexture; uniform sampler2D u_previousFrameTexture;
            uniform float u_time; uniform float u_motionThreshold; uniform float u_trailPersistence;
            uniform float u_hueShiftSpeed; uniform float u_motionExtrapolation;
            float random (vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123 + u_time * 0.01); }
            float noise (vec2 st) { vec2 i = floor(st); vec2 f = fract(st); float a = random(i); float b = random(i + vec2(1.,0.)); float c = random(i + vec2(0.,1.)); float d = random(i + vec2(1.,1.)); vec2 u = f*f*(3.0-2.0*f); return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y; }
            vec3 rgb2hsl(vec3 color) { float r = color.r; float g = color.g; float b = color.b; float maxC = max(max(r, g), b); float minC = min(min(r, g), b); float h = 0.0, s = 0.0, l = (maxC + minC) / 2.0; if (maxC == minC) { h = s = 0.0; } else { float d = maxC - minC; s = l > 0.5 ? d / (2.0 - maxC - minC) : d / (maxC + minC); if (maxC == r) { h = (g - b) / d + (g < b ? 6.0 : 0.0); } else if (maxC == g) { h = (b - r) / d + 2.0; } else if (maxC == b) { h = (r - g) / d + 4.0; } h /= 6.0; } return vec3(h, s, l); }
            float hue2rgb(float p, float q, float t) { if(t < 0.0) t += 1.0; if(t > 1.0) t -= 1.0; if(t < 1.0/6.0) return p + (q - p) * 6.0 * t; if(t < 1.0/2.0) return q; if(t < 2.0/3.0) return p + (q - p) * (2.0/3.0 - t) * 6.0; return p; }
            vec3 hsl2rgb(vec3 hsl) { float h = hsl.x; float s = hsl.y; float l = hsl.z; float r, g, b; if(s == 0.0){ r = g = b = l; } else { float q = l < 0.5 ? l * (1.0 + s) : l + s - l * s; float p = 2.0 * l - q; r = hue2rgb(p, q, h + 1.0/3.0); g = hue2rgb(p, q, h); b = hue2rgb(p, q, h - 1.0/3.0); } return vec3(r, g, b); }
            void main() {
                vec2 mirroredTexCoord = vec2(1.0 - v_texCoord.x, v_texCoord.y);
                vec4 currentWebcamColor = texture2D(u_webcamTexture, mirroredTexCoord);
                vec4 previousOrStaticColor = texture2D(u_previousFrameTexture, v_texCoord);
                float difference = length(currentWebcamColor.rgb - previousOrStaticColor.rgb);
                vec4 finalColor; vec4 motionDerivedColor; vec4 staticDerivedColor;
                vec2 R_offset = vec2(random(mirroredTexCoord.yx + u_time * 0.1) - 0.5) * 0.008;
                vec2 B_offset = vec2(random(mirroredTexCoord.xy - u_time * 0.1) - 0.5) * 0.008;
                motionDerivedColor = vec4( texture2D(u_webcamTexture, mirroredTexCoord + R_offset).r, currentWebcamColor.g, texture2D(u_webcamTexture, mirroredTexCoord + B_offset).b, 1.0 );
                vec2 smearOffset = vec2(noise(v_texCoord*8.0 + u_time*0.05)-0.5) * 0.003;
                vec4 smearedPreviousOrStatic = texture2D(u_previousFrameTexture, v_texCoord + smearOffset);
                staticDerivedColor = mix(currentWebcamColor, smearedPreviousOrStatic, clamp(u_trailPersistence, 0.0, 100.0));
                if (difference > u_motionThreshold) { finalColor = mix(staticDerivedColor, motionDerivedColor, 0.85); } else { finalColor = staticDerivedColor; }
                if (u_motionExtrapolation > 0.0) { vec2 pseudoVelocityOffset = vec2(noise(v_texCoord*8.0 + u_time*0.05)-0.5) * 0.003; vec2 extrapolatedCoord = v_texCoord + pseudoVelocityOffset * u_motionExtrapolation; vec4 extrapolatedColor = texture2D(u_previousFrameTexture, extrapolatedCoord); float extrapolationMix = u_motionExtrapolation * smoothstep(u_motionThreshold + 0.05, u_motionThreshold - 0.05, difference); extrapolationMix = clamp(extrapolationMix, 0.0, 0.9); finalColor = mix(finalColor, extrapolatedColor, extrapolationMix); }
                if (u_hueShiftSpeed != 0.0) {
                    vec3 hsl = rgb2hsl(finalColor.rgb);
                    hsl.x = fract(hsl.x + u_time * u_hueShiftSpeed);
                    if (hsl.y < 0.1) { hsl.y = 0.7; }
                    finalColor.rgb = hsl2rgb(hsl);
                }
                finalColor = clamp(finalColor, 0.0, 1.0); if (finalColor.a < 0.01) discard; gl_FragColor = finalColor;
            }`;
        const fsPassthroughSource = ` precision mediump float; varying vec2 v_texCoord; uniform sampler2D u_textureToDraw; void main() { gl_FragColor = texture2D(u_textureToDraw, v_texCoord); } `;
        const canvas = document.getElementById('outputCanvas');
        const video = document.getElementById('webcamVideo');
        const errorMessageDiv = document.getElementById('errorMessage');
        let gl; let shaderProgram; let passthroughProgram;
        let positionBuffer; let texCoordBuffer;
        let mediaReady = false;
        let startTime = performance.now(); let renderLoopId = null;
        let fbo1, fbo2, fboCopy; let fbTexture1, fbTexture2; let currentSourceFBO, currentDestFBO; let currentSourceTexture, currentDestTexture; let webcamTexture;
        let frameCount = 0; let isFrozen = false; let frozenFrameTextures = []; const MAX_HISTORY_LENGTH = 16; let frameHistoryTextures = []; let historyWriteIndex = 0;
        let controlValues = { trail: 0.9, motion: 0.12, hue: 0.0, history: 6, extrap: 0.0 };
        const freezeButton = document.getElementById('freezeButton'); const clearFreezeButton = document.getElementById('clearFreezeButton');
        const randomizeButton = document.getElementById('randomizeButton');
        const controlsPanel = document.getElementById('controls'); const controlsContent = document.getElementById('controlsContent');
        const minimizeButton = document.getElementById('minimizeButton'); const resizeHandle = document.getElementById('resizeHandle');
        const recordButton = document.getElementById('recordButton');
        const switchCameraButton = document.getElementById('switchCameraButton');
        const fileUploadInput = document.getElementById('fileUploadInput');
        const useWebcamButton = document.getElementById('useWebcamButton');
        let mediaRecorder;
        let recordedChunks = [];
        let isRecording = false;
        const RECORD_BUTTON_RED = '#FF4136';
        const REC_SVG_CIRCLE = `<svg viewBox="0 0 24 24" width="16" height="16"><circle cx="12" cy="12" r="7" fill="${RECORD_BUTTON_RED}"/></svg>`;
        const REC_SVG_SQUARE = `<svg viewBox="0 0 24 24" width="16" height="16"><rect x="7" y="7" width="10" height="10" fill="${RECORD_BUTTON_RED}" rx="1"/></svg>`;
        const SWITCH_CAMERA_SVG = `<svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor"><path d="M17.65 6.35A7.958 7.958 0 0 0 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08A5.99 5.99 0 0 1 12 18c-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/></svg>`;
        let currentInputSource = 'webcam';
        let uploadedMediaElement = null;
        let currentFacingMode = 'user';
        let isResizing = false; let startX, startY, startWidth, startHeight;
        if (!canvas || !video || !freezeButton || !clearFreezeButton || !controlsPanel || !resizeHandle || !randomizeButton || !minimizeButton || !controlsContent || !recordButton || !switchCameraButton || !fileUploadInput || !useWebcamButton) {
            showError("Init Error: Essential UI elements missing!", true); throw new Error("Missing DOM Elements");
        }
        function getControlElements(name) { const range = document.getElementById(`${name}Range`); const number = document.getElementById(`${name}Number`); if (!range || !number) { console.error(`Missing control elements for "${name}"`); } if(range && number && !number.hasAttribute('data-synced')) { number.min = range.min; number.max = range.max; number.step = range.step; number.setAttribute('data-synced', 'true');} return { range, number }; }
        function showError(message, isFatal = true) { console.error(message); if(errorMessageDiv) { errorMessageDiv.textContent = message; errorMessageDiv.style.display = 'block'; setTimeout(() => { if (errorMessageDiv.textContent === message) errorMessageDiv.style.display = 'none'; }, isFatal ? 10000 : 5000); } if(isFatal && renderLoopId) cancelAnimationFrame(renderLoopId); renderLoopId = null; }
        function initWebGL() { gl = canvas.getContext('webgl', { premultipliedAlpha: false, antialias: false }) || canvas.getContext('experimental-webgl', { premultipliedAlpha: false, antialias: false }); if (!gl) { showError('WebGL not supported.'); return false; } return true; }
        function loadShader(type, source) { const shader = gl.createShader(type); gl.shaderSource(shader, source); gl.compileShader(shader); if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) { showError(`Shader compile error: ${gl.getShaderInfoLog(shader)}`); gl.deleteShader(shader); return null; } return shader; }
        function createShaderProgram(vsSource, fsSource) { const vertexShader = loadShader(gl.VERTEX_SHADER, vsSource); const fragmentShader = loadShader(gl.FRAGMENT_SHADER, fsSource); if (!vertexShader || !fragmentShader) return null; const program = gl.createProgram(); gl.attachShader(program, vertexShader); gl.attachShader(program, fragmentShader); gl.linkProgram(program); if (!gl.getProgramParameter(program, gl.LINK_STATUS)) { showError(`Shader link error: ${gl.getProgramInfoLog(program)}`); gl.deleteProgram(program); gl.deleteShader(vertexShader); gl.deleteShader(fragmentShader); return null; } return program; }
        function initBuffers() { positionBuffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer); gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1.,-1., 1.,-1., -1., 1., -1., 1., 1.,-1., 1., 1.,]), gl.STATIC_DRAW); texCoordBuffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer); gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0.,0., 1.,0., 0.,1., 0.,1., 1.,0., 1.,1.,]), gl.STATIC_DRAW); gl.bindBuffer(gl.ARRAY_BUFFER, null); return true; }
        function createAndSetupTexture(width, height) { if (!gl) return null; const tex = gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D, tex); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR); try { gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null); } catch (e) { return null; } return tex; }
        function copyTexture(sourceTexture, destTexture) { if (!gl || !passthroughProgram || !fboCopy || !positionBuffer || !texCoordBuffer) { return; } gl.bindFramebuffer(gl.FRAMEBUFFER, fboCopy); gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, destTexture, 0); gl.viewport(0, 0, canvas.width, canvas.height); gl.useProgram(passthroughProgram); gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, sourceTexture); gl.uniform1i(passthroughProgram.uTextureToDrawLoc, 0); gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer); gl.vertexAttribPointer(passthroughProgram.aPosLoc, 2, gl.FLOAT, false, 0, 0); gl.enableVertexAttribArray(passthroughProgram.aPosLoc); gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer); gl.vertexAttribPointer(passthroughProgram.aTexLoc, 2, gl.FLOAT, false, 0, 0); gl.enableVertexAttribArray(passthroughProgram.aTexLoc); gl.drawArrays(gl.TRIANGLES, 0, 6); gl.bindFramebuffer(gl.FRAMEBUFFER, null); }
        function initFramebuffersAndTextures(width, height) {
            if (fbTexture1) gl.deleteTexture(fbTexture1); if (fbTexture2) gl.deleteTexture(fbTexture2); if (webcamTexture) gl.deleteTexture(webcamTexture);
            frameHistoryTextures.forEach(tex => gl.deleteTexture(tex)); frozenFrameTextures.forEach(tex => gl.deleteTexture(tex));
            fbTexture1 = createAndSetupTexture(width, height); fbTexture2 = createAndSetupTexture(width, height); webcamTexture = createAndSetupTexture(width, height);
            frameHistoryTextures = []; frozenFrameTextures = [];
            if (clearFreezeButton) clearFreezeButton.disabled = true; if (freezeButton) freezeButton.textContent = 'Freeze Frame (0)';
            if (!fbTexture1 || !fbTexture2 || !webcamTexture) { showError("Failed to create FBO textures.", true); return false; }
            for (let i = 0; i < MAX_HISTORY_LENGTH; i++) { const historyTex = createAndSetupTexture(width, height); if (!historyTex) { showError(`Failed to create history texture ${i}.`, true); return false; } frameHistoryTextures.push(historyTex); }
            historyWriteIndex = 0;
            if (fbo1) gl.deleteFramebuffer(fbo1); if (fbo2) gl.deleteFramebuffer(fbo2); if (fboCopy) gl.deleteFramebuffer(fboCopy);
            fbo1 = gl.createFramebuffer(); gl.bindFramebuffer(gl.FRAMEBUFFER, fbo1); gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, fbTexture1, 0);
            fbo2 = gl.createFramebuffer(); gl.bindFramebuffer(gl.FRAMEBUFFER, fbo2); gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, fbTexture2, 0);
            fboCopy = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo1); const status1 = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo2); const status2 = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            if (status1 !== gl.FRAMEBUFFER_COMPLETE || status2 !== gl.FRAMEBUFFER_COMPLETE) { showError(`FBO incomplete. Status1: ${status1}, Status2: ${status2}`, true); return false; }
            currentSourceFBO = fbo2; currentDestFBO = fbo1; currentSourceTexture = fbTexture2; currentDestTexture = fbTexture1;
            gl.bindFramebuffer(gl.FRAMEBUFFER, fboCopy);
            [fbTexture1, fbTexture2, webcamTexture, ...frameHistoryTextures].forEach(tex => { gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0); gl.clearColor(0,0,0,0); gl.clear(gl.COLOR_BUFFER_BIT); });
            gl.bindFramebuffer(gl.FRAMEBUFFER, null); return true;
        }
        function setupMainShaderAttributesUniforms() { gl.useProgram(shaderProgram); const pLoc = gl.getAttribLocation(shaderProgram, 'a_position'); gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer); gl.vertexAttribPointer(pLoc, 2, gl.FLOAT, false, 0, 0); gl.enableVertexAttribArray(pLoc); const tLoc = gl.getAttribLocation(shaderProgram, 'a_texCoord'); gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer); gl.vertexAttribPointer(tLoc, 2, gl.FLOAT, false, 0, 0); gl.enableVertexAttribArray(tLoc); const uniformNames = [ 'u_webcamTexture', 'u_previousFrameTexture', 'u_time', 'u_motionThreshold', 'u_trailPersistence', 'u_hueShiftSpeed', 'u_motionExtrapolation' ]; let allOk = true; uniformNames.forEach(name => { shaderProgram[name + 'Loc'] = gl.getUniformLocation(shaderProgram, name); if (!shaderProgram[name + 'Loc']) { console.error(`Failed to get uniform: ${name}`); allOk = false; } }); if (!allOk) { showError(`Failed to get shader uniforms.`); return false; } gl.bindBuffer(gl.ARRAY_BUFFER, null); return true; }
        function setupPassthroughShaderAttributesUniforms() { gl.useProgram(passthroughProgram); passthroughProgram.aPosLoc = gl.getAttribLocation(passthroughProgram, 'a_position'); passthroughProgram.aTexLoc = gl.getAttribLocation(passthroughProgram, 'a_texCoord'); gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer); gl.vertexAttribPointer(passthroughProgram.aPosLoc, 2, gl.FLOAT, false, 0, 0); gl.enableVertexAttribArray(passthroughProgram.aPosLoc); gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer); gl.vertexAttribPointer(passthroughProgram.aTexLoc, 2, gl.FLOAT, false, 0, 0); gl.enableVertexAttribArray(passthroughProgram.aTexLoc); passthroughProgram.uTextureToDrawLoc = gl.getUniformLocation(passthroughProgram, 'u_textureToDraw'); if (!passthroughProgram.uTextureToDrawLoc || passthroughProgram.aPosLoc < 0 || passthroughProgram.aTexLoc < 0) { showError(`Failed to get passthrough uniforms.`); return false; } gl.bindBuffer(gl.ARRAY_BUFFER, null); return true; }
        function updateSourceTexture() {
            if (!mediaReady) return false; let sourceElement;
            if (currentInputSource === 'webcam') { sourceElement = video; if (video.paused || video.ended || video.readyState < video.HAVE_ENOUGH_DATA) return false;
            } else if (currentInputSource === 'file' && uploadedMediaElement) { sourceElement = uploadedMediaElement;
                if (sourceElement.tagName === 'VIDEO') { if (sourceElement.paused || sourceElement.ended || sourceElement.readyState < sourceElement.HAVE_ENOUGH_DATA) return false;
                } else { if (!sourceElement.complete || sourceElement.naturalWidth === 0) return false; }
            } else { return false; }
            gl.bindTexture(gl.TEXTURE_2D, webcamTexture); gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
            try { gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, sourceElement); return true;
            } catch (e) { console.error("Error updating source texture (texImage2D):", e); return false; }
        }
        const controlConfig = { trail: { precision: 3, isInt: false }, motion: { precision: 2, isInt: false }, hue: { precision: 3, isInt: false }, history: { precision: 0, isInt: true }, extrap: { precision: 2, isInt: false } };
        function updateControlValueFromSlider(controlName, newValue, precision, isInt) {
            const { range, number } = getControlElements(controlName); if (!range || !number) return; let valueToStore = newValue;
            if (controlName === 'history') { valueToStore = Math.max(1, Math.min(Math.round(newValue), MAX_HISTORY_LENGTH)); isInt = true; }
            controlValues[controlName] = valueToStore; range.value = valueToStore; number.value = isInt ? Math.round(valueToStore) : valueToStore.toFixed(precision);
        }
        function setupControl(name) {
            const config = controlConfig[name]; if (!config) { console.error(`No config for: ${name}`); return; } const { precision, isInt } = config; const { range, number } = getControlElements(name); if (!range || !number) return;
            number.addEventListener('input', () => {
                let parsedValue = parseFloat(number.value);
                if (isNaN(parsedValue)) { parsedValue = controlValues[name] || 0; number.value = isInt ? Math.round(parsedValue) : parsedValue.toFixed(precision); }
                if (name === 'history') { parsedValue = Math.max(1, Math.min(Math.round(parsedValue), MAX_HISTORY_LENGTH)); number.value = parsedValue; }
                controlValues[name] = parsedValue; const minR = parseFloat(range.min); const maxR = parseFloat(range.max);
                if (parsedValue >= minR && parsedValue <= maxR) { range.value = parsedValue; } else { if (parsedValue < minR) range.value = minR; if (parsedValue > maxR) range.value = maxR; }
            });
            range.addEventListener('input', () => { updateControlValueFromSlider(name, parseFloat(range.value), precision, isInt); });
            updateControlValueFromSlider(name, controlValues[name], precision, isInt);
        }
        function drawScene(time) {
            if (!gl || !shaderProgram || !passthroughProgram || (!mediaReady && !isFrozen) || !frameHistoryTextures.length) return;
            const sourceTextureUpdated = updateSourceTexture(); if (!sourceTextureUpdated && !isFrozen && controlValues.history <= 1) return;
            let prevFrameTextureToBind;
            if (isFrozen && frozenFrameTextures.length > 0) { let frozenIndex = (frameCount % frozenFrameTextures.length); prevFrameTextureToBind = frozenFrameTextures[frozenIndex];
            } else { let historyLength = Math.max(1, Math.min(Math.round(controlValues.history), frameHistoryTextures.length)); let historyReadIndex = (historyWriteIndex - 1 - (frameCount % historyLength) + frameHistoryTextures.length) % frameHistoryTextures.length; prevFrameTextureToBind = frameHistoryTextures[historyReadIndex]; }
            gl.bindFramebuffer(gl.FRAMEBUFFER, currentDestFBO); gl.viewport(0, 0, canvas.width, canvas.height); gl.useProgram(shaderProgram);
            gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, webcamTexture); gl.uniform1i(shaderProgram.u_webcamTextureLoc, 0);
            gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, prevFrameTextureToBind); gl.uniform1i(shaderProgram.u_previousFrameTextureLoc, 1);
            const elapsedTime = (performance.now() - startTime) * 0.001;
            gl.uniform1f(shaderProgram.u_timeLoc, elapsedTime); gl.uniform1f(shaderProgram.u_motionThresholdLoc, controlValues.motion); gl.uniform1f(shaderProgram.u_trailPersistenceLoc, controlValues.trail); gl.uniform1f(shaderProgram.u_hueShiftSpeedLoc, controlValues.hue); gl.uniform1f(shaderProgram.u_motionExtrapolationLoc, controlValues.extrap);
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            if (!isFrozen) { copyTexture(currentDestTexture, frameHistoryTextures[historyWriteIndex]); historyWriteIndex = (historyWriteIndex + 1) % frameHistoryTextures.length; }
            gl.bindFramebuffer(gl.FRAMEBUFFER, null); gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight); gl.useProgram(passthroughProgram);
            gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, currentDestTexture); gl.uniform1i(passthroughProgram.uTextureToDrawLoc, 0);
            gl.enableVertexAttribArray(passthroughProgram.aPosLoc); gl.enableVertexAttribArray(passthroughProgram.aTexLoc);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer); gl.vertexAttribPointer(passthroughProgram.aPosLoc, 2, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer); gl.vertexAttribPointer(passthroughProgram.aTexLoc, 2, gl.FLOAT, false, 0, 0);
            gl.clearColor(0.0, 0.0, 0.0, 1.0); gl.clear(gl.COLOR_BUFFER_BIT); gl.drawArrays(gl.TRIANGLES, 0, 6);
            if (!isFrozen) { let tempFBO = currentSourceFBO; currentSourceFBO = currentDestFBO; currentDestFBO = tempFBO; let tempTex = currentSourceTexture; currentSourceTexture = currentDestTexture; currentDestTexture = tempTex; }
            const err = gl.getError(); if (err !== gl.NO_ERROR) { } frameCount++;
        }
        function renderLoop(now) { drawScene(now); renderLoopId = requestAnimationFrame(renderLoop); }
        function startRecording() {
            if (!canvas || typeof canvas.captureStream !== 'function') { showError("Recording Error: canvas.captureStream not supported.", false); return; }
            if (typeof MediaRecorder !== 'function') { showError("Recording Error: MediaRecorder not supported.", false); return; }
            const stream = canvas.captureStream(30); recordedChunks = [];
            const mimeTypeOptions = [ { mime: 'video/mp4;codecs=hvc1', extension: 'mp4' }, { mime: 'video/mp4;codecs=avc1', extension: 'mp4' }, { mime: 'video/mp4', extension: 'mp4' }, { mime: 'video/webm', extension: 'webm' } ];
            let selectedMimeTypeInfo = null;
            for (const option of mimeTypeOptions) { if (MediaRecorder.isTypeSupported(option.mime)) { selectedMimeTypeInfo = option; console.log("Supported MIME type for recording:", option.mime); break; } else { console.log("Unsupported MIME type for recording:", option.mime); } }
            if (!selectedMimeTypeInfo) { showError("Recording Error: Neither H.265 (HEVC) nor H.264 (AVC) recording is supported. No suitable video MIME type found.", false); return; }
            const recorderOptions = { mimeType: selectedMimeTypeInfo.mime, videoBitsPerSecond: 8000000, };
            try { mediaRecorder = new MediaRecorder(stream, recorderOptions);
            } catch (e) { console.warn(`MediaRecorder init failed with bitrate option: ${e.toString()}. Retrying without bitrate.`); try { mediaRecorder = new MediaRecorder(stream, { mimeType: selectedMimeTypeInfo.mime }); } catch (e2) { showError(`Recording Error: MediaRecorder init failed: ${e2.toString()}`, false); return; } }
            mediaRecorder.ondataavailable = (event) => { if (event.data && event.data.size > 0) { recordedChunks.push(event.data); } };
            mediaRecorder.onstop = downloadVideo;
            mediaRecorder.onerror = (event) => { showError(`Recording Error: ${event.error.name} - ${event.error.message}`, false); isRecording = false; if (recordButton) { recordButton.innerHTML = REC_SVG_CIRCLE; recordButton.title = "Start Recording"; recordButton.classList.remove('is-recording'); } };
            mediaRecorder.start(); isRecording = true;
            if (recordButton) { recordButton.innerHTML = REC_SVG_SQUARE; recordButton.title = "Stop Recording"; recordButton.classList.add('is-recording'); }
            console.log("Recording started with type: ", mediaRecorder.mimeType, "and options:", recorderOptions);
        }
        function stopRecording() { if (mediaRecorder && mediaRecorder.state === "recording") { mediaRecorder.stop(); } isRecording = false; if (recordButton) { recordButton.innerHTML = REC_SVG_CIRCLE; recordButton.title = "Start Recording"; recordButton.classList.remove('is-recording'); } console.log("Recording stopped."); }
        function downloadVideo() {
            if (recordedChunks.length === 0) { console.warn("No data recorded to download."); return; }
            const actualMimeType = (mediaRecorder && mediaRecorder.mimeType) ? mediaRecorder.mimeType : recordedChunks[0]?.type;
            let fileExtension = 'mp4';
            if (actualMimeType) { if (actualMimeType.startsWith('video/webm')) { fileExtension = 'webm'; } } else if (recordedChunks[0]?.type?.startsWith('video/webm')) { fileExtension = 'webm'; }
            const blob = new Blob(recordedChunks, { type: actualMimeType || `video/${fileExtension}` });
            const url = URL.createObjectURL(blob); const a = document.createElement('a');
            a.style.display = 'none'; a.href = url; a.download = `datamosh_trip_${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.${fileExtension}`;
            document.body.appendChild(a); a.click();
            setTimeout(() => { document.body.removeChild(a); URL.revokeObjectURL(url); }, 100);
            recordedChunks = []; console.log("Video download initiated as", a.download, "with MIME type:", actualMimeType);
        }
        async function setupMediaSource(sourceType, sourceDetail = {}) {
            mediaReady = false;
            if (video.srcObject) { video.srcObject.getTracks().forEach(track => track.stop()); video.srcObject = null; }
            if (video.src && video.src !== '' && !video.src.startsWith('blob:')) { video.pause(); video.removeAttribute('src'); video.load(); }
            if (uploadedMediaElement) { if (uploadedMediaElement.tagName === 'VIDEO') uploadedMediaElement.pause(); if (uploadedMediaElement.src) URL.revokeObjectURL(uploadedMediaElement.src); uploadedMediaElement.removeAttribute('src'); }
            currentInputSource = sourceType;
            if (sourceType === 'webcam') {
                const facingModeToUse = sourceDetail.facingMode || currentFacingMode;
                try {
                    const constraints = { audio: false, video: { width: { ideal: 1280, max: 1920 }, height: { ideal: 720, max: 1080 }, facingMode: {exact: facingModeToUse} } };
                    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) { showError("getUserMedia not supported.", true); return; }
                    const stream = await navigator.mediaDevices.getUserMedia(constraints); currentFacingMode = facingModeToUse;
                    if (!video) { showError("Video element null.", true); return; } video.srcObject = stream;
                    video.onloadedmetadata = () => {
                        if (video.videoWidth === 0 || video.videoHeight === 0) { showError("Webcam video dimensions zero.", true); return; }
                        canvas.width = video.videoWidth; canvas.height = video.videoHeight;
                        if (!initFramebuffersAndTextures(canvas.width, canvas.height)) { showError("FBO/History Init Failed for webcam.", true); return; }
                        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
                        video.play().then(() => { mediaReady = true; startTime = performance.now(); if (renderLoopId === null) { frameCount = 0; renderLoopId = requestAnimationFrame(renderLoop); } useWebcamButton.style.display = 'none'; fileUploadInput.value = null;
                        }).catch(err => { showError(`video.play() failed: ${err.name} - ${err.message}`); });
                    };
                    video.onerror = (e) => { showError(`Webcam video error: ${e?.target?.error?.message || 'Unknown'}`); };
                    stream.addEventListener('inactive', () => { showError("Webcam stream inactive.", false); mediaReady = false; if (freezeButton) freezeButton.disabled = true; if (clearFreezeButton) clearFreezeButton.disabled = true; });
                } catch (err) {
                    showError(`Error accessing webcam (facing: ${facingModeToUse}): ${err.name} - ${err.message}`, err.name !== 'OverconstrainedError');
                    if (sourceDetail.isSwitching && facingModeToUse !== 'user') { console.warn("Failed to switch to environment, trying user."); await setupMediaSource('webcam', { facingMode: 'user' });
                    } else if (sourceDetail.isSwitching && facingModeToUse !== 'environment') { console.warn("Failed to switch to user, trying environment."); await setupMediaSource('webcam', { facingMode: 'environment' }); }
                }
            } else if (sourceType === 'file') {
                const file = sourceDetail.file; if (!file) { showError("No file provided for file source.", false); return; } const objectURL = URL.createObjectURL(file);
                if (file.type.startsWith('image/')) {
                    if (!uploadedMediaElement || uploadedMediaElement.tagName !== 'IMG') { uploadedMediaElement = new Image(); }
                    uploadedMediaElement.onload = () => {
                        if (uploadedMediaElement.naturalWidth === 0 || uploadedMediaElement.naturalHeight === 0) { showError("Uploaded image has zero dimensions.", false); URL.revokeObjectURL(objectURL); return; }
                        canvas.width = uploadedMediaElement.naturalWidth; canvas.height = uploadedMediaElement.naturalHeight;
                        if (!initFramebuffersAndTextures(canvas.width, canvas.height)) { showError("FBO init failed for uploaded image.", true); URL.revokeObjectURL(objectURL); return; }
                        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight); mediaReady = true; startTime = performance.now();
                        if (renderLoopId === null) { renderLoopId = requestAnimationFrame(renderLoop); } useWebcamButton.style.display = 'block';
                    };
                    uploadedMediaElement.onerror = () => { showError("Error loading uploaded image.", false); URL.revokeObjectURL(objectURL); setupMediaSource('webcam'); };
                    uploadedMediaElement.src = objectURL;
                } else if (file.type.startsWith('video/')) {
                    if (!uploadedMediaElement || uploadedMediaElement.tagName !== 'VIDEO') { uploadedMediaElement = document.createElement('video'); uploadedMediaElement.autoplay = true; uploadedMediaElement.muted = true; uploadedMediaElement.playsInline = true; }
                    uploadedMediaElement.loop = true;
                    uploadedMediaElement.onloadedmetadata = () => {
                        if (uploadedMediaElement.videoWidth === 0 || uploadedMediaElement.videoHeight === 0) { showError("Uploaded video has zero dimensions.", false); URL.revokeObjectURL(objectURL); return; }
                        canvas.width = uploadedMediaElement.videoWidth; canvas.height = uploadedMediaElement.videoHeight;
                        if (!initFramebuffersAndTextures(canvas.width, canvas.height)) { showError("FBO init failed for uploaded video.", true); URL.revokeObjectURL(objectURL); return; }
                        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
                        uploadedMediaElement.play().then(() => { mediaReady = true; startTime = performance.now(); if (renderLoopId === null) { renderLoopId = requestAnimationFrame(renderLoop); } useWebcamButton.style.display = 'block';
                        }).catch(err => { showError(`Uploaded video play failed: ${err.message}`, false); URL.revokeObjectURL(objectURL); });
                    };
                    uploadedMediaElement.onerror = (e) => { showError(`Uploaded video error: ${e.target.error?.message || 'Unknown error'}`, false); URL.revokeObjectURL(objectURL); setupMediaSource('webcam'); };
                    uploadedMediaElement.src = objectURL;
                } else { showError("Unsupported file type. Please upload an image or video.", false); URL.revokeObjectURL(objectURL); setupMediaSource('webcam'); }
            }
        }
        async function main() {
            if (!errorMessageDiv) { return; }
            if (!initWebGL() || !initBuffers()) { showError("WebGL/Buffer Init Failed.", true); return; }
            shaderProgram = createShaderProgram(vsSource, fsSource); passthroughProgram = createShaderProgram(vsSource, fsPassthroughSource);
            if (!shaderProgram || !passthroughProgram) { showError("Shader Program Creation Failed.", true); return; }
            if (!setupMainShaderAttributesUniforms() || !setupPassthroughShaderAttributesUniforms()) { showError("Shader Setup Failed.", true); return; }
            Object.keys(controlConfig).forEach(name => { if (controlValues.hasOwnProperty(name)) { setupControl(name); } });
            recordButton.innerHTML = REC_SVG_CIRCLE; switchCameraButton.innerHTML = SWITCH_CAMERA_SVG;
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || (navigator.maxTouchPoints && navigator.maxTouchPoints > 0 && window.matchMedia("(pointer:coarse)").matches);
            if (isMobile && navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {
                try {
                    const devices = await navigator.mediaDevices.enumerateDevices(); const videoInputs = devices.filter(device => device.kind === 'videoinput');
                    if (videoInputs.length > 1) { switchCameraButton.style.display = 'flex'; } else { switchCameraButton.style.display = 'none'; }
                } catch (err) { console.warn("Could not enumerate devices:", err); switchCameraButton.style.display = 'none'; }
            } else { switchCameraButton.style.display = 'none'; }
            await setupMediaSource('webcam', { facingMode: currentFacingMode });
        }
        freezeButton.addEventListener('click', () => { if (!gl || (!mediaReady && !isFrozen) || !currentDestTexture) return; isFrozen = true; const frozenTexture = createAndSetupTexture(canvas.width, canvas.height); if (!frozenTexture) { return; } copyTexture(currentDestTexture, frozenTexture); frozenFrameTextures.push(frozenTexture); freezeButton.textContent = `Freeze Frame (${frozenFrameTextures.length})`; clearFreezeButton.disabled = false; });
        clearFreezeButton.addEventListener('click', () => { if (!gl) return; isFrozen = false; frozenFrameTextures.forEach(tex => gl.deleteTexture(tex)); frozenFrameTextures = []; freezeButton.textContent = 'Freeze Frame (0)'; clearFreezeButton.disabled = true; });
        randomizeButton.addEventListener('click', () => {
            const excludedControls = ['history', 'hue'];
            Object.keys(controlValues).forEach(controlName => {
                if (excludedControls.includes(controlName)) return; const config = controlConfig[controlName]; const { range, number } = getControlElements(controlName); if (!range || !number || !config) { return; }
                const minVal = parseFloat(range.min); const maxVal = parseFloat(range.max); const stepVal = parseFloat(range.step) || 0.01;
                if (isNaN(minVal) || isNaN(maxVal) || isNaN(stepVal) || stepVal <= 0 || minVal > maxVal) { return; }
                if (minVal === maxVal) { updateControlValueFromSlider(controlName, minVal, config.precision, config.isInt); return; }
                const numSteps = Math.round((maxVal - minVal) / stepVal); const randomStepIndex = Math.floor(Math.random() * (numSteps + 1));
                let randomValue = minVal + randomStepIndex * stepVal; randomValue = Math.max(minVal, Math.min(maxVal, randomValue));
                updateControlValueFromSlider(controlName, randomValue, config.precision, config.isInt);
            });
        });
        recordButton.addEventListener('click', () => { if (!mediaReady && !isFrozen) { showError("Media not ready and no frozen content. Cannot record.", false); return; } if (isRecording) { stopRecording(); } else { startRecording(); } });
        switchCameraButton.addEventListener('click', async () => { const newFacingMode = (currentFacingMode === 'user') ? 'environment' : 'user'; await setupMediaSource('webcam', { facingMode: newFacingMode, isSwitching: true }); });
        fileUploadInput.addEventListener('change', async (event) => { const file = event.target.files[0]; if (file) { await setupMediaSource('file', { file: file }); } event.target.value = null; });
        useWebcamButton.addEventListener('click', async () => { await setupMediaSource('webcam', { facingMode: currentFacingMode }); });
        resizeHandle.addEventListener('mousedown', (e) => { if (controlsPanel.classList.contains('minimized')) return; isResizing = true; startX = e.clientX; startY = e.clientY; startWidth = controlsPanel.offsetWidth; startHeight = controlsPanel.offsetHeight; controlsPanel.style.userSelect = 'none'; controlsPanel.style.pointerEvents = 'none'; window.addEventListener('mousemove', handleMouseMove); window.addEventListener('mouseup', handleMouseUp); e.preventDefault(); });
        function handleMouseMove(e) { if (!isResizing) return; const dx = e.clientX - startX; const dy = e.clientY - startY; let newWidth = startWidth + dx; let newHeight = startHeight + dy; newWidth = Math.max(parseInt(controlsPanel.style.minWidth) || 230, newWidth); newHeight = Math.max(parseInt(controlsPanel.style.minHeight) || 150, newHeight); controlsPanel.style.width = `${newWidth}px`; controlsPanel.style.height = `${newHeight}px`; }
        function handleMouseUp() { if (isResizing) { isResizing = false; controlsPanel.style.userSelect = ''; controlsPanel.style.pointerEvents = ''; window.removeEventListener('mousemove', handleMouseMove); window.removeEventListener('mouseup', handleMouseUp); if (!controlsPanel.classList.contains('minimized')) { controlsPanel.dataset.originalHeight = controlsPanel.offsetHeight + 'px'; } } }
        minimizeButton.addEventListener('click', () => {
            if (controlsPanel.classList.contains('minimized')) {
                controlsPanel.classList.remove('minimized'); minimizeButton.innerHTML = '<svg viewBox="0 0 24 24"><path d="M19 13H5v-2h14v2z"/></svg>'; minimizeButton.title = "Minimize Controls";
                controlsPanel.style.height = controlsPanel.dataset.originalHeight || 'auto';
                controlsPanel.addEventListener('transitionend', function onMaximizeEnd(event) { if (event.target === controlsPanel && event.propertyName === 'height' && !controlsPanel.classList.contains('minimized')) { controlsPanel.style.height = 'auto'; controlsPanel.removeEventListener('transitionend', onMaximizeEnd); } }, { once: false });
                setTimeout(() => { controlsContent.style.opacity = 1; resizeHandle.style.opacity = 0.4;}, 50);
            } else {
                if (!controlsPanel.dataset.originalHeight || controlsPanel.style.height === 'auto') { controlsPanel.dataset.originalHeight = controlsPanel.offsetHeight + 'px'; }
                controlsPanel.style.height = controlsPanel.offsetHeight + 'px'; requestAnimationFrame(() => { controlsPanel.classList.add('minimized'); });
                minimizeButton.innerHTML = '<svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>'; minimizeButton.title = "Maximize Controls";
                controlsContent.style.opacity = 0; resizeHandle.style.opacity = 0;
            }
        });
        controlsPanel.addEventListener('keydown', (e) => {
            const focusableNumberInputs = Array.from(controlsContent.querySelectorAll('input[type="number"]'));
            const currentNumberIndex = focusableNumberInputs.indexOf(document.activeElement);
            if (e.key === 'w' || e.key === 'W' || e.key === 's' || e.key === 'S') {
                e.preventDefault(); let targetInput;
                if (currentNumberIndex === -1 && focusableNumberInputs.length > 0) { targetInput = focusableNumberInputs[e.key === 'w' || e.key === 'W' ? focusableNumberInputs.length - 1 : 0];
                } else if (currentNumberIndex !== -1) { let nextIndex = currentNumberIndex + (e.key === 's' || e.key === 'S' ? 1 : -1); nextIndex = (nextIndex + focusableNumberInputs.length) % focusableNumberInputs.length; targetInput = focusableNumberInputs[nextIndex]; }
                if (targetInput) { targetInput.focus(); targetInput.select(); }
            }
        });
        const donateModal = document.getElementById('donateModal');
        const openDonateButton = document.getElementById('donateButton');
        const closeDonateButton = donateModal.querySelector('.donate-close-button');
        const donationListContainer = donateModal.querySelector('.donation-list');
        openDonateButton.onclick = function() {
            donateModal.style.display = 'block';
            const allQrAreas = donationListContainer.querySelectorAll('.qr-code-area');
            allQrAreas.forEach(area => { area.style.display = 'none'; const qrContainer = area.querySelector('.qr-code-container'); if (qrContainer) qrContainer.innerHTML = ''; });
        }
        closeDonateButton.onclick = function() {
            donateModal.style.display = 'none';
            const allQrAreas = donationListContainer.querySelectorAll('.qr-code-area');
            allQrAreas.forEach(area => { area.style.display = 'none'; const qrContainer = area.querySelector('.qr-code-container'); if (qrContainer) qrContainer.innerHTML = ''; });
        }
        window.onclick = function(event) { if (event.target == donateModal) { closeDonateButton.onclick(); } }
        donationListContainer.addEventListener('click', function(event) {
            const target = event.target.closest('button'); if (!target) return;
            if (target.classList.contains('copy-button')) {
                const addressToCopy = target.dataset.address;
                navigator.clipboard.writeText(addressToCopy).then(() => {
                    const originalText = target.textContent; target.textContent = 'Copied!'; target.classList.add('copied');
                    setTimeout(() => { target.textContent = originalText; target.classList.remove('copied'); }, 1500);
                }).catch(err => { console.error('Failed to copy address: ', err); target.textContent = 'Error!'; setTimeout(() => { target.textContent = 'Copy'; }, 1500); });
            }
            if (target.classList.contains('qr-button')) {
                const addressForQR = target.dataset.address;
                const qrArea = target.closest('.donation-option').querySelector('.qr-code-area');
                const qrContainer = qrArea.querySelector('.qr-code-container');
                if (qrContainer) {
                    if (qrArea.style.display === 'block' && qrContainer.innerHTML !== '') { qrContainer.innerHTML = ''; qrArea.style.display = 'none';
                    } else {
                        const allQrAreas = donationListContainer.querySelectorAll('.qr-code-area');
                        allQrAreas.forEach(area => { area.style.display = 'none'; const otherQrContainer = area.querySelector('.qr-code-container'); if (otherQrContainer) otherQrContainer.innerHTML = ''; });
                        qrContainer.innerHTML = ''; qrArea.style.display = 'block';
                        try { new QRCode(qrContainer, { text: addressForQR, width: 128, height: 128, colorDark : "#000000", colorLight : "#ffffff", correctLevel : QRCode.CorrectLevel.H });
                        } catch (error) { console.error("QR Code generation failed:", error); qrContainer.textContent = 'QR Error'; setTimeout(() => { qrArea.style.display = 'none'; qrContainer.innerHTML = ''; }, 1500); }
                    }
                }
            }
        });
        // --- WEBSOCKET AUTO-CONFIG ---
        const parameterConfig = {
            trail: { min: 0.0, max: 1.5 },
            motion: { min: 0.0, max: 1.0 },
            hue: { min: -0.2, max: 0.2 },
            history: { min: 1, max: 16 },
            extrap: { min: 0.0, max: 2.0 },
        }
        function connectWS() {
            const ws = new WebSocket(`ws://${window.location.hostname}:6789/tatr/autoconfig`);
            ws.onopen = () => {
                ws.send(JSON.stringify({
                    kind: "visual",
                    parameters: Object.entries(parameterConfig).map(([name, conf]) => { return { name, range: [conf.min, conf.max] } })
                }));
            };
            ws.onmessage = ({ data }) => {
                const msg = JSON.parse(data);
                if (controlConfig.hasOwnProperty(msg.on)) {
                    controlValues[msg.on] = msg.value
                }
            };
            ws.onclose = () => setTimeout(connectWS, 1000);
            ws.onerror = e => { console.error(e); ws.close(); };
        };
        connectWS();
        main();
    </script>
</body>
</html>
