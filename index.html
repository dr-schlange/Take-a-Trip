<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>TAKE A TRIP! - Real-time Datamosh</title>
    <style>
        @keyframes rainbowText {
            0% { color: #ff00ff; text-shadow: 0 0 7px #ff00ff; }
            16% { color: #007bff; text-shadow: 0 0 7px #007bff; }
            33% { color: #00ff00; text-shadow: 0 0 7px #00ff00; }
            50% { color: #ffff00; text-shadow: 0 0 7px #ffff00; }
            66% { color: #ff7f00; text-shadow: 0 0 7px #ff7f00; }
            83% { color: #ff0000; text-shadow: 0 0 7px #ff0000; }
            100% { color: #ff00ff; text-shadow: 0 0 7px #ff00ff; }
        }

        @keyframes rainbowBackground {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        html, body {
            margin: 0; padding: 0; overflow: hidden;
            width: 100%; height: 100%;
            background-color: #0a0a0f;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            color: #e8e8e8;
        }
        canvas { display: block; width: 100%; height: 100%; object-fit: contain; }
        #errorMessage { position: absolute; top: 10px; left: 10px; background-color: rgba(255, 0, 100, 0.9); padding: 12px; border-radius: 6px; display: none; z-index: 1001; color: white; font-size: 14px; box-shadow: 0 0 20px rgba(255,0,100,0.7); }
        #webcamVideo { position: absolute; top: -9999px; left: -9999px; }

        #controls {
            position: absolute; bottom: 10px; left: 10px;
            background-color: rgba(15, 18, 28, 0.65);
            padding: 12px;
            border-radius: 12px;
            font-size: 12px;
            display: flex; flex-direction: column;
            width: 290px;
            max-width: 90vw; max-height: 88vh;
            z-index: 1000;
            overflow: hidden;
            min-width: 240px;
            border: 1px solid rgba(70, 80, 110, 0.8);
            box-shadow: 0 8px 35px rgba(0,0,0,0.6), 0 0 50px rgba(100, 150, 255, 0.1);
            transition: height 0.3s cubic-bezier(0.25, 0.1, 0.25, 1), min-height 0.3s cubic-bezier(0.25, 0.1, 0.25, 1), opacity 0.3s ease-out;
        }

        #controlsHeader {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(60, 70, 95, 0.8);
            position: relative; 
        }

        #controlsTitle {
            font-weight: 700;
            font-size: 18px;
            animation: rainbowText 10s linear infinite;
        }

        #minimizeButton {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(120, 150, 200, 0.5);
            color: #aaa;
            cursor: pointer;
            padding: 0;
            border-radius: 50%;
            width: 20px; height: 20px;
            display: flex; align-items: center; justify-content: center;
            transition: background-color 0.2s, transform 0.2s, color 0.2s, box-shadow 0.2s;
            flex-shrink: 0;
        }
        #minimizeButton:hover {
            background: rgba(255, 255, 255, 0.15);
            color: #fff;
            transform: scale(1.15);
            box-shadow: 0 0 10px rgba(150, 180, 255, 0.5);
        }
        #minimizeButton svg { width: 12px; height: 12px; fill: currentColor; }

        #controlsContent {
            overflow-y: auto; overflow-x: hidden;
            padding-right: 3px;
            display: flex; flex-direction: column; gap: 10px;
            transition: opacity 0.2s 0.1s ease-out;
        }

        #controls.minimized {
            height: 52px !important;
            min-height: 52px !important;
            background-color: rgba(15, 18, 28, 0.55);
        }
        #controls.minimized #controlsContent,
        #controls.minimized #resizeHandle {
            opacity: 0;
            pointer-events: none;
        }

        #controls .main-action-button {
            width: 100%; box-sizing: border-box;
            margin-top: 6px;
            padding: 7px 10px;
            background: linear-gradient(120deg, red, orange, yellow, green, blue, indigo, violet, red);
            background-size: 300% 300%;
            animation: rainbowBackground 8s linear infinite;
            border: none;
            color: white; cursor: pointer; border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
            text-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        #controls .main-action-button:hover {
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 6px 15px rgba(0,0,0,0.2);
        }
        #controls .main-action-button:active {
            transform: translateY(0px) scale(1);
            animation-duration: 4s;
        }
        #controls .main-action-button:disabled {
            background-image: none; background-color: #3a3a45;
            color: #777; cursor: default; transform: none; box-shadow: none;
            animation: none;
        }

        .control-group { display: flex; flex-wrap: nowrap; align-items: center; gap: 8px; }
        .control-group label {
            flex-basis: 75px;
            flex-shrink: 0;
            font-size: 12.5px;
            font-weight: 500;
            color: #77ccff;
            text-shadow: 0 0 5px rgba(100, 200, 255, 0.5);
        }

        .control-group input[type="range"] {
            flex-grow: 1; min-width: 80px;
            height: 20px; margin: 0;
            -webkit-appearance: none; appearance: none;
            background: transparent; cursor: pointer;
        }
        .control-group input[type="range"]::-webkit-slider-runnable-track {
            height: 10px;
            background: linear-gradient(90deg, #ff00ff, #00ffff, #ffff00, #ff00ff, #00ffff, #ffff00);
            background-size: 400% 100%;
            animation: rainbowBackground 12s linear infinite;
            border-radius: 5px;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.4);
        }
        .control-group input[type="range"]::-moz-range-track {
            height: 10px;
            background: linear-gradient(90deg, #ff00ff, #00ffff, #ffff00, #ff00ff, #00ffff, #ffff00);
            background-size: 400% 100%;
            animation: rainbowBackground 12s linear infinite;
            border-radius: 5px; border: none;
        }
        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none;
            height: 18px; width: 18px;
            background-color: #ffffff;
            border-radius: 50%; border: 2px solid #10121a;
            box-shadow: 0 0 6px #fff, 0 0 12px #fff, 0 0 18px rgba(200,220,255,0.8);
            margin-top: -4px;
        }
        .control-group input[type="range"]::-moz-range-thumb {
            height: 16px; width: 16px;
            background-color: #ffffff;
            border-radius: 50%; border: 2px solid #10121a;
            box-shadow: 0 0 6px #fff, 0 0 12px #fff, 0 0 18px rgba(200,220,255,0.8);
        }

        .control-group input[type="number"] {
            width: 55px;
            flex-shrink: 0; text-align: right; padding: 5px 6px;
            background-color: rgba(20, 22, 30, 0.8); color: #66ffee;
            border: 1px solid rgba(80, 90, 120, 0.9);
            border-radius: 4px; -moz-appearance: textfield; appearance: textfield; font-size: 12px;
            font-weight: 500;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.3);
        }
        .control-group input[type="number"]::-webkit-outer-spin-button,
        .control-group input[type="number"]::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }

        .button-group { display: flex; gap: 10px; margin-top: 8px; }
        .button-group button { flex-grow: 1; }

        #resizeHandle {
            position: absolute; bottom: 0; right: 0;
            width: 16px; height: 16px;
            cursor: nwse-resize; z-index: 1000;
            display: flex; align-items: flex-end; justify-content: flex-end;
            opacity: 0.4;
        }
        #resizeHandle::before {
            content: ""; display: block;
            width: 8px; height: 8px;
            border-right: 2.5px solid #66ffee;
            border-bottom: 2.5px solid #66ffee;
            margin: 0 2px 2px 0;
            opacity: 0.6;
        }
        #resizeHandle:hover { opacity: 0.8; }

        .record-button {
            padding: 0;
            background-color: #282c34;
            border: 1px solid #4f5661;
            cursor: pointer;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s, transform 0.15s ease, box-shadow 0.15s ease;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            flex-shrink: 0;
        }
        .record-button:hover {
            background-color: #3a3f47;
            transform: scale(1.05); 
            box-shadow: 0 4px 10px rgba(0,0,0,0.4);
        }
        .record-button:active {
            background-color: #1c1e22;
            transform: scale(1);
        }
        .record-button.is-recording {
            animation: blink 1.5s linear infinite;
        }
        .record-button svg {
            display: block;
            margin: auto;
        }
    </style>
</head>
<body>
    <canvas id="outputCanvas"></canvas>
    <video id="webcamVideo" playsinline autoplay muted></video>
    <div id="errorMessage"></div>

    <div id="controls">
        <div id="controlsHeader">
            <span id="controlsTitle">TAKE A TRIP!</span>
            <button id="recordButton" class="record-button" title="Start Recording">
                 <!-- SVG will be injected by JS -->
            </button>
            <button id="minimizeButton" title="Minimize Controls">
                <svg viewBox="0 0 24 24"><path d="M19 13H5v-2h14v2z"/></svg>
            </button>
        </div>
        <div id="controlsContent">
            <div class="control-group"> <label for="trailRange">Trail:</label> <input type="range" id="trailRange" min="0.0" max="1.5" step="0.005" value="0.9"> <input type="number" id="trailNumber" step="0.005" value="0.9"> </div>
            <div class="control-group"> <label for="motionRange">Motion:</label> <input type="range" id="motionRange" min="0.0" max="1.0" step="0.01" value="0.12"> <input type="number" id="motionNumber" step="0.01" value="0.12"> </div>
            <div class="control-group"> <label for="hueRange">Hue:</label> <input type="range" id="hueRange" min="-0.2" max="0.2" step="0.001" value="0.0"> <input type="number" id="hueNumber" step="0.001" value="0.0"> </div>
            <div class="control-group"> <label for="historyRange">History:</label> <input type="range" id="historyRange" min="1" max="16" step="1" value="6"> <input type="number" id="historyNumber" min="1" max="16" step="1" value="6"> </div>
            <div class="control-group"> <label for="extrapRange">Extrap:</label> <input type="range" id="extrapRange" min="0.0" max="2.0" step="0.01" value="0.0"> <input type="number" id="extrapNumber" step="0.01" value="0.0"> </div>

            <div class="button-group">
                <button id="freezeButton" class="main-action-button">Freeze Frame (0)</button>
                <button id="clearFreezeButton" class="main-action-button" disabled>Clear Frozen</button>
            </div>
            <button id="randomizeButton" class="main-action-button">Randomize Sliders</button>
        </div>
        <div id="resizeHandle"></div>
    </div>

    <script>
        const vsSource = ` attribute vec4 a_position; attribute vec2 a_texCoord; varying vec2 v_texCoord; void main() { gl_Position = a_position; v_texCoord = a_texCoord; } `;
        const fsSource = `
            precision highp float; varying vec2 v_texCoord;
            uniform sampler2D u_webcamTexture; uniform sampler2D u_previousFrameTexture;
            uniform float u_time; uniform float u_motionThreshold; uniform float u_trailPersistence;
            uniform float u_hueShiftSpeed; uniform float u_motionExtrapolation;
            float random (vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123 + u_time * 0.01); }
            float noise (vec2 st) { vec2 i = floor(st); vec2 f = fract(st); float a = random(i); float b = random(i + vec2(1.,0.)); float c = random(i + vec2(0.,1.)); float d = random(i + vec2(1.,1.)); vec2 u = f*f*(3.0-2.0*f); return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y; }
            vec3 rgb2hsl(vec3 color) { float r = color.r; float g = color.g; float b = color.b; float maxC = max(max(r, g), b); float minC = min(min(r, g), b); float h = 0.0, s = 0.0, l = (maxC + minC) / 2.0; if (maxC == minC) { h = s = 0.0; } else { float d = maxC - minC; s = l > 0.5 ? d / (2.0 - maxC - minC) : d / (maxC + minC); if (maxC == r) { h = (g - b) / d + (g < b ? 6.0 : 0.0); } else if (maxC == g) { h = (b - r) / d + 2.0; } else if (maxC == b) { h = (r - g) / d + 4.0; } h /= 6.0; } return vec3(h, s, l); }
            float hue2rgb(float p, float q, float t) { if(t < 0.0) t += 1.0; if(t > 1.0) t -= 1.0; if(t < 1.0/6.0) return p + (q - p) * 6.0 * t; if(t < 1.0/2.0) return q; if(t < 2.0/3.0) return p + (q - p) * (2.0/3.0 - t) * 6.0; return p; }
            vec3 hsl2rgb(vec3 hsl) { float h = hsl.x; float s = hsl.y; float l = hsl.z; float r, g, b; if(s == 0.0){ r = g = b = l; } else { float q = l < 0.5 ? l * (1.0 + s) : l + s - l * s; float p = 2.0 * l - q; r = hue2rgb(p, q, h + 1.0/3.0); g = hue2rgb(p, q, h); b = hue2rgb(p, q, h - 1.0/3.0); } return vec3(r, g, b); }
            void main() {
                vec2 mirroredTexCoord = vec2(1.0 - v_texCoord.x, v_texCoord.y);
                vec4 currentWebcamColor = texture2D(u_webcamTexture, mirroredTexCoord);
                vec4 previousOrStaticColor = texture2D(u_previousFrameTexture, v_texCoord); 
                float difference = length(currentWebcamColor.rgb - previousOrStaticColor.rgb);
                vec4 finalColor; vec4 motionDerivedColor; vec4 staticDerivedColor;
                vec2 R_offset = vec2(random(mirroredTexCoord.yx + u_time * 0.1) - 0.5) * 0.008;
                vec2 B_offset = vec2(random(mirroredTexCoord.xy - u_time * 0.1) - 0.5) * 0.008;
                motionDerivedColor = vec4( texture2D(u_webcamTexture, mirroredTexCoord + R_offset).r, currentWebcamColor.g, texture2D(u_webcamTexture, mirroredTexCoord + B_offset).b, 1.0 );
                vec2 smearOffset = vec2(noise(v_texCoord*8.0 + u_time*0.05)-0.5) * 0.003;
                vec4 smearedPreviousOrStatic = texture2D(u_previousFrameTexture, v_texCoord + smearOffset);
                staticDerivedColor = mix(currentWebcamColor, smearedPreviousOrStatic, clamp(u_trailPersistence, 0.0, 100.0));
                if (difference > u_motionThreshold) { finalColor = mix(staticDerivedColor, motionDerivedColor, 0.85); } else { finalColor = staticDerivedColor; }
                if (u_motionExtrapolation > 0.0) { vec2 pseudoVelocityOffset = vec2(noise(v_texCoord*8.0 + u_time*0.05)-0.5) * 0.003; vec2 extrapolatedCoord = v_texCoord + pseudoVelocityOffset * u_motionExtrapolation; vec4 extrapolatedColor = texture2D(u_previousFrameTexture, extrapolatedCoord); float extrapolationMix = u_motionExtrapolation * smoothstep(u_motionThreshold + 0.05, u_motionThreshold - 0.05, difference); extrapolationMix = clamp(extrapolationMix, 0.0, 0.9); finalColor = mix(finalColor, extrapolatedColor, extrapolationMix); }
                
                if (u_hueShiftSpeed != 0.0) {
                    vec3 hsl = rgb2hsl(finalColor.rgb);
                    hsl.x = fract(hsl.x + u_time * u_hueShiftSpeed);
                    if (hsl.y < 0.1) { hsl.y = 0.7; }
                    finalColor.rgb = hsl2rgb(hsl);
                }
                finalColor = clamp(finalColor, 0.0, 1.0); if (finalColor.a < 0.01) discard; gl_FragColor = finalColor;
            }`;
        const fsPassthroughSource = ` precision mediump float; varying vec2 v_texCoord; uniform sampler2D u_textureToDraw; void main() { gl_FragColor = texture2D(u_textureToDraw, v_texCoord); } `;

        const canvas = document.getElementById('outputCanvas'); const video = document.getElementById('webcamVideo'); const errorMessageDiv = document.getElementById('errorMessage');
        let gl; let shaderProgram; let passthroughProgram;
        let positionBuffer; let texCoordBuffer; let videoReady = false; let startTime = performance.now(); let renderLoopId = null;
        let fbo1, fbo2, fboCopy; let fbTexture1, fbTexture2; let currentSourceFBO, currentDestFBO; let currentSourceTexture, currentDestTexture; let webcamTexture;
        let frameCount = 0; let isFrozen = false; let frozenFrameTextures = []; const MAX_HISTORY_LENGTH = 16; let frameHistoryTextures = []; let historyWriteIndex = 0;
        let controlValues = { trail: 0.9, motion: 0.12, hue: 0.0, history: 6, extrap: 0.0 };

        const freezeButton = document.getElementById('freezeButton'); const clearFreezeButton = document.getElementById('clearFreezeButton');
        const randomizeButton = document.getElementById('randomizeButton');
        const controlsPanel = document.getElementById('controls'); const controlsContent = document.getElementById('controlsContent');
        const minimizeButton = document.getElementById('minimizeButton'); const resizeHandle = document.getElementById('resizeHandle');
        const recordButton = document.getElementById('recordButton'); 

        let mediaRecorder;
        let recordedChunks = [];
        let isRecording = false;
        const RECORD_BUTTON_RED = '#FF4136'; 
        const REC_SVG_CIRCLE = `<svg viewBox="0 0 24 24" width="16" height="16"><circle cx="12" cy="12" r="7" fill="${RECORD_BUTTON_RED}"/></svg>`;
        const REC_SVG_SQUARE = `<svg viewBox="0 0 24 24" width="16" height="16"><rect x="7" y="7" width="10" height="10" fill="${RECORD_BUTTON_RED}" rx="1"/></svg>`;

        if (!canvas || !video || !freezeButton || !clearFreezeButton || !controlsPanel || !resizeHandle || !randomizeButton || !minimizeButton || !controlsContent || !recordButton) {
            showError("Init Error: Essential UI elements missing!", true); throw new Error("Missing DOM Elements");
        }

        function getControlElements(name) { const range = document.getElementById(`${name}Range`); const number = document.getElementById(`${name}Number`); if (!range || !number) { console.error(`Missing control elements for "${name}"`); } if(range && number && !number.hasAttribute('data-synced')) { number.min = range.min; number.max = range.max; number.step = range.step; number.setAttribute('data-synced', 'true');} return { range, number }; }
        function showError(message, isFatal = true) { console.error(message); if(errorMessageDiv) { errorMessageDiv.textContent = message; errorMessageDiv.style.display = 'block'; } if(isFatal && renderLoopId) cancelAnimationFrame(renderLoopId); renderLoopId = null; }
        function initWebGL() { gl = canvas.getContext('webgl', { premultipliedAlpha: false, antialias: false }) || canvas.getContext('experimental-webgl', { premultipliedAlpha: false, antialias: false }); if (!gl) { showError('WebGL not supported.'); return false; } return true; }
        function loadShader(type, source) { const shader = gl.createShader(type); gl.shaderSource(shader, source); gl.compileShader(shader); if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) { showError(`Shader compile error: ${gl.getShaderInfoLog(shader)}`); gl.deleteShader(shader); return null; } return shader; }
        function createShaderProgram(vsSource, fsSource) { const vertexShader = loadShader(gl.VERTEX_SHADER, vsSource); const fragmentShader = loadShader(gl.FRAGMENT_SHADER, fsSource); if (!vertexShader || !fragmentShader) return null; const program = gl.createProgram(); gl.attachShader(program, vertexShader); gl.attachShader(program, fragmentShader); gl.linkProgram(program); if (!gl.getProgramParameter(program, gl.LINK_STATUS)) { showError(`Shader link error: ${gl.getProgramInfoLog(program)}`); gl.deleteProgram(program); gl.deleteShader(vertexShader); gl.deleteShader(fragmentShader); return null; } return program; }
        function initBuffers() { positionBuffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer); gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1.,-1., 1.,-1., -1., 1., -1., 1., 1.,-1., 1., 1.,]), gl.STATIC_DRAW); texCoordBuffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer); gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0.,0., 1.,0., 0.,1., 0.,1., 1.,0., 1.,1.,]), gl.STATIC_DRAW); gl.bindBuffer(gl.ARRAY_BUFFER, null); return true; }
        function createAndSetupTexture(width, height) { if (!gl) return null; const tex = gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D, tex); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR); try { gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null); } catch (e) { return null; } return tex; }
        function copyTexture(sourceTexture, destTexture) { if (!gl || !passthroughProgram || !fboCopy || !positionBuffer || !texCoordBuffer) { return; } gl.bindFramebuffer(gl.FRAMEBUFFER, fboCopy); gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, destTexture, 0); gl.viewport(0, 0, canvas.width, canvas.height); gl.useProgram(passthroughProgram); gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, sourceTexture); gl.uniform1i(passthroughProgram.uTextureToDrawLoc, 0); gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer); gl.vertexAttribPointer(passthroughProgram.aPosLoc, 2, gl.FLOAT, false, 0, 0); gl.enableVertexAttribArray(passthroughProgram.aPosLoc); gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer); gl.vertexAttribPointer(passthroughProgram.aTexLoc, 2, gl.FLOAT, false, 0, 0); gl.enableVertexAttribArray(passthroughProgram.aTexLoc); gl.drawArrays(gl.TRIANGLES, 0, 6); gl.bindFramebuffer(gl.FRAMEBUFFER, null); }
        function initFramebuffers(width, height) { fbTexture1 = createAndSetupTexture(width, height); fbTexture2 = createAndSetupTexture(width, height); webcamTexture = createAndSetupTexture(width, height); frameHistoryTextures.forEach(tex => gl.deleteTexture(tex)); frameHistoryTextures = []; frozenFrameTextures.forEach(tex => gl.deleteTexture(tex)); frozenFrameTextures = []; if (clearFreezeButton) clearFreezeButton.disabled = true; if (freezeButton) freezeButton.textContent = 'Freeze Frame (0)'; if (!fbTexture1 || !fbTexture2 || !webcamTexture) { showError("Failed to create FBO textures.", true); return false; } for (let i = 0; i < MAX_HISTORY_LENGTH; i++) { const historyTex = createAndSetupTexture(width, height); if (!historyTex) { showError(`Failed to create history texture ${i}.`, true); return false; } frameHistoryTextures.push(historyTex); } historyWriteIndex = 0; fbo1 = gl.createFramebuffer(); gl.bindFramebuffer(gl.FRAMEBUFFER, fbo1); gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, fbTexture1, 0); fbo2 = gl.createFramebuffer(); gl.bindFramebuffer(gl.FRAMEBUFFER, fbo2); gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, fbTexture2, 0); fboCopy = gl.createFramebuffer(); gl.bindFramebuffer(gl.FRAMEBUFFER, fbo1); const status1 = gl.checkFramebufferStatus(gl.FRAMEBUFFER); gl.bindFramebuffer(gl.FRAMEBUFFER, fbo2); const status2 = gl.checkFramebufferStatus(gl.FRAMEBUFFER); gl.bindFramebuffer(gl.FRAMEBUFFER, null); if (status1 !== gl.FRAMEBUFFER_COMPLETE || status2 !== gl.FRAMEBUFFER_COMPLETE) { showError(`FBO incomplete.`); return false; } currentSourceFBO = fbo2; currentDestFBO = fbo1; currentSourceTexture = fbTexture2; currentDestTexture = fbTexture1; gl.bindFramebuffer(gl.FRAMEBUFFER, fboCopy); [fbTexture1, fbTexture2, ...frameHistoryTextures].forEach(tex => { gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0); gl.clearColor(0,0,0,0); gl.clear(gl.COLOR_BUFFER_BIT); }); gl.bindFramebuffer(gl.FRAMEBUFFER, null); return true; }
        function setupMainShaderAttributesUniforms() { gl.useProgram(shaderProgram); const pLoc = gl.getAttribLocation(shaderProgram, 'a_position'); gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer); gl.vertexAttribPointer(pLoc, 2, gl.FLOAT, false, 0, 0); gl.enableVertexAttribArray(pLoc); const tLoc = gl.getAttribLocation(shaderProgram, 'a_texCoord'); gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer); gl.vertexAttribPointer(tLoc, 2, gl.FLOAT, false, 0, 0); gl.enableVertexAttribArray(tLoc); const uniformNames = [ 'u_webcamTexture', 'u_previousFrameTexture', 'u_time', 'u_motionThreshold', 'u_trailPersistence', 'u_hueShiftSpeed', 'u_motionExtrapolation' ]; let allOk = true; uniformNames.forEach(name => { shaderProgram[name + 'Loc'] = gl.getUniformLocation(shaderProgram, name); if (!shaderProgram[name + 'Loc']) { console.error(`Failed to get uniform: ${name}`); allOk = false; } }); if (!allOk) { showError(`Failed to get shader uniforms.`); return false; } gl.bindBuffer(gl.ARRAY_BUFFER, null); return true; }
        function setupPassthroughShaderAttributesUniforms() { gl.useProgram(passthroughProgram); passthroughProgram.aPosLoc = gl.getAttribLocation(passthroughProgram, 'a_position'); passthroughProgram.aTexLoc = gl.getAttribLocation(passthroughProgram, 'a_texCoord'); gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer); gl.vertexAttribPointer(passthroughProgram.aPosLoc, 2, gl.FLOAT, false, 0, 0); gl.enableVertexAttribArray(passthroughProgram.aPosLoc); gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer); gl.vertexAttribPointer(passthroughProgram.aTexLoc, 2, gl.FLOAT, false, 0, 0); gl.enableVertexAttribArray(passthroughProgram.aTexLoc); passthroughProgram.uTextureToDrawLoc = gl.getUniformLocation(passthroughProgram, 'u_textureToDraw'); if (!passthroughProgram.uTextureToDrawLoc || passthroughProgram.aPosLoc < 0 || passthroughProgram.aTexLoc < 0) { showError(`Failed to get passthrough uniforms.`); return false; } gl.bindBuffer(gl.ARRAY_BUFFER, null); return true; }
        function updateWebcamTexture() { if (!videoReady || video.paused || video.ended || video.readyState < video.HAVE_ENOUGH_DATA) return false; gl.bindTexture(gl.TEXTURE_2D, webcamTexture); gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true); try { gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video); return true; } catch (e) { return false; } }

        const controlConfig = {
            trail: { precision: 3, isInt: false }, motion: { precision: 2, isInt: false },
            hue: { precision: 3, isInt: false }, history: { precision: 0, isInt: true },
            extrap: { precision: 2, isInt: false }
        };

        function updateControlValueFromSlider(controlName, newValue, precision, isInt) {
            const { range, number } = getControlElements(controlName); if (!range || !number) return;
            let valueToStore = newValue;
            if (controlName === 'history') { valueToStore = Math.max(1, Math.min(Math.round(newValue), MAX_HISTORY_LENGTH)); isInt = true; }
            controlValues[controlName] = valueToStore; range.value = valueToStore;
            number.value = isInt ? Math.round(valueToStore) : valueToStore.toFixed(precision);
        }

        function setupControl(name) {
            const config = controlConfig[name]; if (!config) { console.error(`No config for: ${name}`); return; }
            const { precision, isInt } = config;
            const { range, number } = getControlElements(name); if (!range || !number) return;
            number.addEventListener('input', () => {
                let parsedValue = parseFloat(number.value);
                if (isNaN(parsedValue)) { parsedValue = controlValues[name] || 0; number.value = isInt ? Math.round(parsedValue) : parsedValue.toFixed(precision); }
                if (name === 'history') { parsedValue = Math.max(1, Math.min(Math.round(parsedValue), MAX_HISTORY_LENGTH)); number.value = parsedValue; }
                controlValues[name] = parsedValue;
                const minR = parseFloat(range.min); const maxR = parseFloat(range.max);
                if (parsedValue >= minR && parsedValue <= maxR) { range.value = parsedValue; }
                else { if (parsedValue < minR) range.value = minR; if (parsedValue > maxR) range.value = maxR; }
            });
            range.addEventListener('input', () => { updateControlValueFromSlider(name, parseFloat(range.value), precision, isInt); });
            updateControlValueFromSlider(name, controlValues[name], precision, isInt);
        }

        function drawScene(time) { if (!gl || !shaderProgram || !passthroughProgram || (!videoReady && !isFrozen) || !frameHistoryTextures.length) return; const webcamTextureUpdated = updateWebcamTexture(); if (!webcamTextureUpdated && !isFrozen && controlValues.history <= 1) return; let prevFrameTextureToBind; if (isFrozen && frozenFrameTextures.length > 0) { let frozenIndex = (frameCount % frozenFrameTextures.length); prevFrameTextureToBind = frozenFrameTextures[frozenIndex]; } else { let historyLength = Math.max(1, Math.min(Math.round(controlValues.history), frameHistoryTextures.length)); let historyReadIndex = (historyWriteIndex - 1 - (frameCount % historyLength) + frameHistoryTextures.length) % frameHistoryTextures.length; prevFrameTextureToBind = frameHistoryTextures[historyReadIndex]; } gl.bindFramebuffer(gl.FRAMEBUFFER, currentDestFBO); gl.viewport(0, 0, canvas.width, canvas.height); gl.useProgram(shaderProgram); gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, webcamTexture); gl.uniform1i(shaderProgram.u_webcamTextureLoc, 0); gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, prevFrameTextureToBind); gl.uniform1i(shaderProgram.u_previousFrameTextureLoc, 1); const elapsedTime = (performance.now() - startTime) * 0.001; gl.uniform1f(shaderProgram.u_timeLoc, elapsedTime); gl.uniform1f(shaderProgram.u_motionThresholdLoc, controlValues.motion); gl.uniform1f(shaderProgram.u_trailPersistenceLoc, controlValues.trail); gl.uniform1f(shaderProgram.u_hueShiftSpeedLoc, controlValues.hue); gl.uniform1f(shaderProgram.u_motionExtrapolationLoc, controlValues.extrap); gl.drawArrays(gl.TRIANGLES, 0, 6); if (!isFrozen) { copyTexture(currentDestTexture, frameHistoryTextures[historyWriteIndex]); historyWriteIndex = (historyWriteIndex + 1) % frameHistoryTextures.length; } gl.bindFramebuffer(gl.FRAMEBUFFER, null); gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight); gl.useProgram(passthroughProgram); gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, currentDestTexture); gl.uniform1i(passthroughProgram.uTextureToDrawLoc, 0); gl.enableVertexAttribArray(passthroughProgram.aPosLoc); gl.enableVertexAttribArray(passthroughProgram.aTexLoc); gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer); gl.vertexAttribPointer(passthroughProgram.aPosLoc, 2, gl.FLOAT, false, 0, 0); gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer); gl.vertexAttribPointer(passthroughProgram.aTexLoc, 2, gl.FLOAT, false, 0, 0); gl.clearColor(0.0, 0.0, 0.0, 1.0); gl.clear(gl.COLOR_BUFFER_BIT); gl.drawArrays(gl.TRIANGLES, 0, 6); if (!isFrozen) { let tempFBO = currentSourceFBO; currentSourceFBO = currentDestFBO; currentDestFBO = tempFBO; let tempTex = currentSourceTexture; currentSourceTexture = currentDestTexture; currentDestTexture = tempTex; } const err = gl.getError(); if (err !== gl.NO_ERROR) { /* Error logging suppressed */ } frameCount++; }
        function renderLoop(now) { drawScene(now); renderLoopId = requestAnimationFrame(renderLoop); }
        
        function startRecording() {
            if (!canvas || typeof canvas.captureStream !== 'function') {
                showError("Recording Error: canvas.captureStream not supported.", false);
                return;
            }
            if (typeof MediaRecorder !== 'function') {
                showError("Recording Error: MediaRecorder not supported.", false);
                return;
            }
            const stream = canvas.captureStream(30); 
            recordedChunks = [];

            // Prioritized list of MIME types and codecs
            const mimeTypeOptions = [
                { mime: 'video/webm;codecs=av01', extension: 'webm' }, // AV1
                { mime: 'video/mp4;codecs=hvc1', extension: 'mp4' },  // HEVC/H.265
                { mime: 'video/webm;codecs=vp9', extension: 'webm' },  // VP9
                { mime: 'video/mp4;codecs=avc1', extension: 'mp4' },  // H.264
                { mime: 'video/webm;codecs=vp8', extension: 'webm' },  // VP8
                { mime: 'video/webm', extension: 'webm' },
                { mime: 'video/mp4', extension: 'mp4' }
            ];

            let selectedMimeTypeInfo = null;
            for (const option of mimeTypeOptions) {
                if (MediaRecorder.isTypeSupported(option.mime)) {
                    selectedMimeTypeInfo = option;
                    break;
                }
            }

            if (!selectedMimeTypeInfo) {
                showError("Recording Error: No suitable video MIME type found.", false);
                return;
            }

            const recorderOptions = {
                mimeType: selectedMimeTypeInfo.mime,
                videoBitsPerSecond: 8000000, // Target 8 Mbps for higher quality
            };

            try {
                mediaRecorder = new MediaRecorder(stream, recorderOptions);
            } catch (e) {
                console.warn(`MediaRecorder init failed with bitrate option: ${e.toString()}. Retrying without bitrate.`);
                try {
                    mediaRecorder = new MediaRecorder(stream, { mimeType: selectedMimeTypeInfo.mime });
                } catch (e2) {
                    showError(`Recording Error: MediaRecorder init failed: ${e2.toString()}`, false);
                    return;
                }
            }

            mediaRecorder.ondataavailable = (event) => {
                if (event.data && event.data.size > 0) {
                    recordedChunks.push(event.data);
                }
            };
            mediaRecorder.onstop = downloadVideo; 
            mediaRecorder.onerror = (event) => {
                showError(`Recording Error: ${event.error.name} - ${event.error.message}`, false);
                isRecording = false;
                if (recordButton) {
                    recordButton.innerHTML = REC_SVG_CIRCLE;
                    recordButton.title = "Start Recording";
                    recordButton.classList.remove('is-recording');
                }
            };
            mediaRecorder.start();
            isRecording = true;
            if (recordButton) {
                recordButton.innerHTML = REC_SVG_SQUARE;
                recordButton.title = "Stop Recording";
                recordButton.classList.add('is-recording');
            }
            console.log("Recording started with type: ", mediaRecorder.mimeType, "and options:", recorderOptions);
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state === "recording") {
                mediaRecorder.stop();
            }
            isRecording = false;
            if (recordButton) {
                recordButton.innerHTML = REC_SVG_CIRCLE;
                recordButton.title = "Start Recording";
                recordButton.classList.remove('is-recording');
            }
            console.log("Recording stopped.");
        }

        function downloadVideo() {
            if (recordedChunks.length === 0) {
                console.warn("No data recorded to download.");
                return;
            }

            const actualMimeType = (mediaRecorder && mediaRecorder.mimeType) ? mediaRecorder.mimeType : recordedChunks[0]?.type;
            let fileExtension = 'webm'; // Default extension

            if (actualMimeType) {
                if (actualMimeType.startsWith('video/mp4')) {
                    fileExtension = 'mp4';
                } else if (actualMimeType.startsWith('video/webm')) {
                    fileExtension = 'webm';
                }
            } else if (recordedChunks[0]?.type?.startsWith('video/mp4')) {
                fileExtension = 'mp4';
            }


            const blob = new Blob(recordedChunks, { type: actualMimeType || `video/${fileExtension}` });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = `datamosh_trip_${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.${fileExtension}`;
            document.body.appendChild(a);
            a.click();
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);
            recordedChunks = [];
            console.log("Video download initiated as", a.download, "with MIME type:", actualMimeType);
        }

        async function main() { if (!errorMessageDiv) { return; } if (!initWebGL() || !initBuffers()) { showError("WebGL/Buffer Init Failed.", true); return; } shaderProgram = createShaderProgram(vsSource, fsSource); passthroughProgram = createShaderProgram(vsSource, fsPassthroughSource); if (!shaderProgram || !passthroughProgram) { showError("Shader Program Creation Failed.", true); return; } if (!setupMainShaderAttributesUniforms() || !setupPassthroughShaderAttributesUniforms()) { showError("Shader Setup Failed.", true); return; } try { const constraints = { audio: false, video: { width: { ideal: 1280, max: 1920 }, height: { ideal: 720, max: 1080 }, facingMode: 'user' } }; if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) { showError("getUserMedia not supported.", true); return; } const stream = await navigator.mediaDevices.getUserMedia(constraints); if (!video) { showError("Video element null.", true); return; } video.srcObject = stream; video.onloadedmetadata = () => { if (video.videoWidth === 0 || video.videoHeight === 0) { showError("Video dimensions zero.", true); return; } if (!initFramebuffers(video.videoWidth, video.videoHeight)) { showError("FBO/History Init Failed.", true); return; } canvas.width = video.videoWidth; canvas.height = video.videoHeight; gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight); video.play().then(() => { videoReady = true; startTime = performance.now(); if (renderLoopId === null) { frameCount=0; renderLoopId = requestAnimationFrame(renderLoop); } }).catch(err => { showError(`video.play() failed: ${err.name} - ${err.message}`); }); }; video.onerror = (e) => { showError(`Video error.`); }; stream.addEventListener('inactive', () => { showError("Webcam stream inactive.", false); videoReady = false; if (freezeButton) freezeButton.disabled = true; if (clearFreezeButton) clearFreezeButton.disabled = true; }); } catch (err) { if (err.name === 'OverconstrainedError' || err.name === 'ConstraintNotSatisfiedError') { showError(`Video resolution not supported.`, false); } else if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') { showError(`Camera Permission Denied.`, true); } else if (err.name === 'NotFoundError' || err.name === 'DevicesNotFoundError') { showError(`No camera found.`, true); } else { showError(`Error accessing webcam.`, true); } } }

        Object.keys(controlConfig).forEach(name => { if (controlValues.hasOwnProperty(name)) { setupControl(name); } });

        freezeButton.addEventListener('click', () => { if (!gl || (!videoReady && !isFrozen) || !currentDestTexture) return; isFrozen = true; const frozenTexture = createAndSetupTexture(canvas.width, canvas.height); if (!frozenTexture) { return; } copyTexture(currentDestTexture, frozenTexture); frozenFrameTextures.push(frozenTexture); freezeButton.textContent = `Freeze Frame (${frozenFrameTextures.length})`; clearFreezeButton.disabled = false; });
        clearFreezeButton.addEventListener('click', () => { if (!gl) return; isFrozen = false; frozenFrameTextures.forEach(tex => gl.deleteTexture(tex)); frozenFrameTextures = []; freezeButton.textContent = 'Freeze Frame (0)'; clearFreezeButton.disabled = true; });
        
        randomizeButton.addEventListener('click', () => {
            const excludedControls = ['history', 'hue']; 
            Object.keys(controlValues).forEach(controlName => {
                if (excludedControls.includes(controlName)) return;
                const config = controlConfig[controlName];
                const { range, number } = getControlElements(controlName);
                if (!range || !number || !config) { return; }
                const minVal = parseFloat(range.min);
                const maxVal = parseFloat(range.max);
                const stepVal = parseFloat(range.step) || 0.01;
                if (isNaN(minVal) || isNaN(maxVal) || isNaN(stepVal) || stepVal <= 0 || minVal > maxVal) { return; }
                if (minVal === maxVal) {
                    updateControlValueFromSlider(controlName, minVal, config.precision, config.isInt);
                    return;
                }
                const numSteps = Math.round((maxVal - minVal) / stepVal);
                const randomStepIndex = Math.floor(Math.random() * (numSteps + 1));
                let randomValue = minVal + randomStepIndex * stepVal;
                randomValue = Math.max(minVal, Math.min(maxVal, randomValue));
                updateControlValueFromSlider(controlName, randomValue, config.precision, config.isInt);
            });
        });

        if (recordButton) {
            recordButton.innerHTML = REC_SVG_CIRCLE; 
            recordButton.addEventListener('click', () => {
                if (!videoReady && !isFrozen) { 
                    showError("Webcam not ready and no frozen content. Cannot record.", false);
                    return;
                }
                if (isRecording) { stopRecording(); } else { startRecording(); }
            });
        }

        resizeHandle.addEventListener('mousedown', (e) => { if (controlsPanel.classList.contains('minimized')) return; isResizing = true; startX = e.clientX; startY = e.clientY; startWidth = controlsPanel.offsetWidth; startHeight = controlsPanel.offsetHeight; controlsPanel.style.userSelect = 'none'; controlsPanel.style.pointerEvents = 'none'; window.addEventListener('mousemove', handleMouseMove); window.addEventListener('mouseup', handleMouseUp); e.preventDefault(); });
        function handleMouseMove(e) { if (!isResizing) return; const dx = e.clientX - startX; const dy = e.clientY - startY; let newWidth = startWidth + dx; let newHeight = startHeight + dy; newWidth = Math.max(parseInt(controlsPanel.style.minWidth) || 230, newWidth); newHeight = Math.max(parseInt(controlsPanel.style.minHeight) || 150, newHeight); controlsPanel.style.width = `${newWidth}px`; controlsPanel.style.height = `${newHeight}px`; }
        function handleMouseUp() { 
            if (isResizing) { 
                isResizing = false; 
                controlsPanel.style.userSelect = ''; 
                controlsPanel.style.pointerEvents = ''; 
                window.removeEventListener('mousemove', handleMouseMove); 
                window.removeEventListener('mouseup', handleMouseUp); 
                if (!controlsPanel.classList.contains('minimized')) {
                    controlsPanel.dataset.originalHeight = controlsPanel.offsetHeight + 'px'; 
                }
            } 
        }
        minimizeButton.addEventListener('click', () => { 
            if (controlsPanel.classList.contains('minimized')) { 
                controlsPanel.classList.remove('minimized'); 
                minimizeButton.innerHTML = '<svg viewBox="0 0 24 24"><path d="M19 13H5v-2h14v2z"/></svg>'; 
                minimizeButton.title = "Minimize Controls"; 
                controlsPanel.style.height = controlsPanel.dataset.originalHeight || 'auto'; 
                
                controlsPanel.addEventListener('transitionend', function onMaximizeEnd(event) {
                    if (event.target === controlsPanel && event.propertyName === 'height' && !controlsPanel.classList.contains('minimized')) {
                        controlsPanel.style.height = 'auto'; 
                    }
                }, { once: true });

                setTimeout(() => { controlsContent.style.opacity = 1; resizeHandle.style.opacity = 0.4;}, 50); 
            } else { 
                if (!controlsPanel.dataset.originalHeight || controlsPanel.style.height === 'auto') {
                     controlsPanel.dataset.originalHeight = controlsPanel.offsetHeight + 'px';
                }
                controlsPanel.style.height = controlsPanel.offsetHeight + 'px'; 
                
                requestAnimationFrame(() => { 
                    controlsPanel.classList.add('minimized'); 
                });

                minimizeButton.innerHTML = '<svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>'; 
                minimizeButton.title = "Maximize Controls"; 
                controlsContent.style.opacity = 0; 
                resizeHandle.style.opacity = 0; 
            } 
        });

        controlsPanel.addEventListener('keydown', (e) => {
            const focusableNumberInputs = Array.from(controlsContent.querySelectorAll('input[type="number"]'));
            const currentNumberIndex = focusableNumberInputs.indexOf(document.activeElement);
            if (e.key === 'w' || e.key === 'W' || e.key === 's' || e.key === 'S') {
                e.preventDefault();
                let targetInput;
                if (currentNumberIndex === -1 && focusableNumberInputs.length > 0) {
                    targetInput = focusableNumberInputs[e.key === 'w' || e.key === 'W' ? focusableNumberInputs.length - 1 : 0];
                } else if (currentNumberIndex !== -1) {
                    let nextIndex = currentNumberIndex + (e.key === 's' || e.key === 'S' ? 1 : -1);
                    nextIndex = (nextIndex + focusableNumberInputs.length) % focusableNumberInputs.length;
                    targetInput = focusableNumberInputs[nextIndex];
                }
                if (targetInput) { targetInput.focus(); targetInput.select(); }
            }
        });

        main();
    </script>
</body>
</html>
